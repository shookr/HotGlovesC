
HotGloves.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007c  00800100  00000f1a  00000fae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f1a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004f  0080017c  0080017c  0000102a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000102a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000105c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000158  00000000  00000000  00001098  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d0c  00000000  00000000  000011f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c50  00000000  00000000  00002efc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cec  00000000  00000000  00003b4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000034c  00000000  00000000  00004838  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006fe  00000000  00000000  00004b84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000119c  00000000  00000000  00005282  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  0000641e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
   4:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
   8:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
   c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  10:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  14:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  18:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  1c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  20:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  24:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  28:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  2c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  30:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  34:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  38:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  3c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  40:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  44:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  48:	0c 94 44 04 	jmp	0x888	; 0x888 <__vector_18>
  4c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  50:	0c 94 58 04 	jmp	0x8b0	; 0x8b0 <__vector_20>
  54:	0c 94 86 04 	jmp	0x90c	; 0x90c <__vector_21>
  58:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  5c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  60:	0c 94 4e 04 	jmp	0x89c	; 0x89c <__vector_24>
  64:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  68:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>
  6c:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__bad_interrupt>

00000070 <__trampolines_end>:
  70:	0d 52       	subi	r16, 0x2D	; 45
  72:	2c 31       	cpi	r18, 0x1C	; 28
  74:	0d 00       	.word	0x000d	; ????

00000076 <__c.2243>:
  76:	2b 0d 00                                            +..

00000079 <__c.2241>:
  79:	24 24 24 0d 00                                      $$$..

0000007e <__ctors_end>:
  7e:	11 24       	eor	r1, r1
  80:	1f be       	out	0x3f, r1	; 63
  82:	cf ef       	ldi	r28, 0xFF	; 255
  84:	d0 e1       	ldi	r29, 0x10	; 16
  86:	de bf       	out	0x3e, r29	; 62
  88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a0 e0       	ldi	r26, 0x00	; 0
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	ea e1       	ldi	r30, 0x1A	; 26
  92:	ff e0       	ldi	r31, 0x0F	; 15
  94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
  96:	05 90       	lpm	r0, Z+
  98:	0d 92       	st	X+, r0
  9a:	ac 37       	cpi	r26, 0x7C	; 124
  9c:	b1 07       	cpc	r27, r17
  9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
  a0:	21 e0       	ldi	r18, 0x01	; 1
  a2:	ac e7       	ldi	r26, 0x7C	; 124
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
  a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
  aa:	ab 3c       	cpi	r26, 0xCB	; 203
  ac:	b2 07       	cpc	r27, r18
  ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>
  b0:	0e 94 55 03 	call	0x6aa	; 0x6aa <main>
  b4:	0c 94 8b 07 	jmp	0xf16	; 0xf16 <_exit>

000000b8 <__bad_interrupt>:
  b8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000bc <toggle_e>:

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
    }

}/* lcd_puts_p */
  bc:	46 9a       	sbi	0x08, 6	; 8
  be:	00 c0       	rjmp	.+0      	; 0xc0 <toggle_e+0x4>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <toggle_e+0x6>
  c2:	46 98       	cbi	0x08, 6	; 8
  c4:	08 95       	ret

000000c6 <lcd_write>:
  c6:	cf 93       	push	r28
  c8:	df 93       	push	r29
  ca:	d8 2f       	mov	r29, r24
  cc:	66 23       	and	r22, r22
  ce:	11 f0       	breq	.+4      	; 0xd4 <lcd_write+0xe>
  d0:	44 9a       	sbi	0x08, 4	; 8
  d2:	01 c0       	rjmp	.+2      	; 0xd6 <lcd_write+0x10>
  d4:	44 98       	cbi	0x08, 4	; 8
  d6:	45 98       	cbi	0x08, 5	; 8
  d8:	87 b1       	in	r24, 0x07	; 7
  da:	8f 60       	ori	r24, 0x0F	; 15
  dc:	87 b9       	out	0x07, r24	; 7
  de:	c8 b1       	in	r28, 0x08	; 8
  e0:	c0 7f       	andi	r28, 0xF0	; 240
  e2:	8d 2f       	mov	r24, r29
  e4:	82 95       	swap	r24
  e6:	8f 70       	andi	r24, 0x0F	; 15
  e8:	8c 2b       	or	r24, r28
  ea:	88 b9       	out	0x08, r24	; 8
  ec:	0e 94 5e 00 	call	0xbc	; 0xbc <toggle_e>
  f0:	df 70       	andi	r29, 0x0F	; 15
  f2:	dc 2b       	or	r29, r28
  f4:	d8 b9       	out	0x08, r29	; 8
  f6:	0e 94 5e 00 	call	0xbc	; 0xbc <toggle_e>
  fa:	cf 60       	ori	r28, 0x0F	; 15
  fc:	c8 b9       	out	0x08, r28	; 8
  fe:	df 91       	pop	r29
 100:	cf 91       	pop	r28
 102:	08 95       	ret

00000104 <lcd_read>:
 104:	88 23       	and	r24, r24
 106:	11 f0       	breq	.+4      	; 0x10c <lcd_read+0x8>
 108:	44 9a       	sbi	0x08, 4	; 8
 10a:	01 c0       	rjmp	.+2      	; 0x10e <lcd_read+0xa>
 10c:	44 98       	cbi	0x08, 4	; 8
 10e:	45 9a       	sbi	0x08, 5	; 8
 110:	87 b1       	in	r24, 0x07	; 7
 112:	80 7f       	andi	r24, 0xF0	; 240
 114:	87 b9       	out	0x07, r24	; 7
 116:	46 9a       	sbi	0x08, 6	; 8
 118:	00 c0       	rjmp	.+0      	; 0x11a <lcd_read+0x16>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <lcd_read+0x18>
 11c:	96 b1       	in	r25, 0x06	; 6
 11e:	46 98       	cbi	0x08, 6	; 8
 120:	00 c0       	rjmp	.+0      	; 0x122 <lcd_read+0x1e>
 122:	00 c0       	rjmp	.+0      	; 0x124 <lcd_read+0x20>
 124:	46 9a       	sbi	0x08, 6	; 8
 126:	00 c0       	rjmp	.+0      	; 0x128 <lcd_read+0x24>
 128:	00 c0       	rjmp	.+0      	; 0x12a <lcd_read+0x26>
 12a:	26 b1       	in	r18, 0x06	; 6
 12c:	2f 70       	andi	r18, 0x0F	; 15
 12e:	89 2f       	mov	r24, r25
 130:	82 95       	swap	r24
 132:	80 7f       	andi	r24, 0xF0	; 240
 134:	46 98       	cbi	0x08, 6	; 8
 136:	82 2b       	or	r24, r18
 138:	08 95       	ret

0000013a <lcd_waitbusy>:
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	0e 94 82 00 	call	0x104	; 0x104 <lcd_read>
 140:	88 23       	and	r24, r24
 142:	dc f3       	brlt	.-10     	; 0x13a <lcd_waitbusy>
 144:	85 e0       	ldi	r24, 0x05	; 5
 146:	8a 95       	dec	r24
 148:	f1 f7       	brne	.-4      	; 0x146 <lcd_waitbusy+0xc>
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	0e 94 82 00 	call	0x104	; 0x104 <lcd_read>
 150:	08 95       	ret

00000152 <lcd_command>:
 152:	cf 93       	push	r28
 154:	c8 2f       	mov	r28, r24
 156:	0e 94 9d 00 	call	0x13a	; 0x13a <lcd_waitbusy>
 15a:	60 e0       	ldi	r22, 0x00	; 0
 15c:	8c 2f       	mov	r24, r28
 15e:	0e 94 63 00 	call	0xc6	; 0xc6 <lcd_write>
 162:	cf 91       	pop	r28
 164:	08 95       	ret

00000166 <lcd_gotoxy>:
 166:	61 11       	cpse	r22, r1
 168:	04 c0       	rjmp	.+8      	; 0x172 <lcd_gotoxy+0xc>
 16a:	80 58       	subi	r24, 0x80	; 128
 16c:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
 170:	08 95       	ret
 172:	80 54       	subi	r24, 0x40	; 64
 174:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
 178:	08 95       	ret

0000017a <lcd_clrscr>:
 17a:	81 e0       	ldi	r24, 0x01	; 1
 17c:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
 180:	08 95       	ret

00000182 <lcd_putc>:
 182:	cf 93       	push	r28
 184:	c8 2f       	mov	r28, r24
 186:	0e 94 9d 00 	call	0x13a	; 0x13a <lcd_waitbusy>
 18a:	ca 30       	cpi	r28, 0x0A	; 10
 18c:	49 f4       	brne	.+18     	; 0x1a0 <lcd_putc+0x1e>
 18e:	80 34       	cpi	r24, 0x40	; 64
 190:	10 f0       	brcs	.+4      	; 0x196 <lcd_putc+0x14>
 192:	80 e0       	ldi	r24, 0x00	; 0
 194:	01 c0       	rjmp	.+2      	; 0x198 <lcd_putc+0x16>
 196:	80 e4       	ldi	r24, 0x40	; 64
 198:	80 58       	subi	r24, 0x80	; 128
 19a:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
 19e:	04 c0       	rjmp	.+8      	; 0x1a8 <lcd_putc+0x26>
 1a0:	61 e0       	ldi	r22, 0x01	; 1
 1a2:	8c 2f       	mov	r24, r28
 1a4:	0e 94 63 00 	call	0xc6	; 0xc6 <lcd_write>
 1a8:	cf 91       	pop	r28
 1aa:	08 95       	ret

000001ac <lcd_puts>:
 1ac:	cf 93       	push	r28
 1ae:	df 93       	push	r29
 1b0:	ec 01       	movw	r28, r24
 1b2:	21 96       	adiw	r28, 0x01	; 1
 1b4:	fc 01       	movw	r30, r24
 1b6:	80 81       	ld	r24, Z
 1b8:	88 23       	and	r24, r24
 1ba:	29 f0       	breq	.+10     	; 0x1c6 <lcd_puts+0x1a>
 1bc:	0e 94 c1 00 	call	0x182	; 0x182 <lcd_putc>
 1c0:	89 91       	ld	r24, Y+
 1c2:	81 11       	cpse	r24, r1
 1c4:	fb cf       	rjmp	.-10     	; 0x1bc <lcd_puts+0x10>
 1c6:	df 91       	pop	r29
 1c8:	cf 91       	pop	r28
 1ca:	08 95       	ret

000001cc <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 1cc:	cf 93       	push	r28
 1ce:	c8 2f       	mov	r28, r24
      && ( &LCD_RS_PORT == &LCD_DATA0_PORT) && ( &LCD_RW_PORT == &LCD_DATA0_PORT) && (&LCD_E_PORT == &LCD_DATA0_PORT)
      && (LCD_DATA0_PIN == 0 ) && (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) 
      && (LCD_RS_PIN == 4 ) && (LCD_RW_PIN == 5) && (LCD_E_PIN == 6 ) )
    {
        /* configure all port bits as output (all LCD lines on same port) */
        DDR(LCD_DATA0_PORT) |= 0x7F;
 1d0:	87 b1       	in	r24, 0x07	; 7
 1d2:	8f 67       	ori	r24, 0x7F	; 127
 1d4:	87 b9       	out	0x07, r24	; 7
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1d6:	89 e9       	ldi	r24, 0x99	; 153
 1d8:	99 e3       	ldi	r25, 0x39	; 57
 1da:	01 97       	sbiw	r24, 0x01	; 1
 1dc:	f1 f7       	brne	.-4      	; 0x1da <lcd_init+0xe>
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <lcd_init+0x14>
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(LCD_DELAY_BOOTUP);             /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);    // LCD_FUNCTION>>4;
 1e0:	41 9a       	sbi	0x08, 1	; 8
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);    // LCD_FUNCTION_8BIT>>4;
 1e2:	40 9a       	sbi	0x08, 0	; 8
    lcd_e_toggle();
 1e4:	0e 94 5e 00 	call	0xbc	; 0xbc <toggle_e>
 1e8:	8f ef       	ldi	r24, 0xFF	; 255
 1ea:	91 e1       	ldi	r25, 0x11	; 17
 1ec:	01 97       	sbiw	r24, 0x01	; 1
 1ee:	f1 f7       	brne	.-4      	; 0x1ec <lcd_init+0x20>
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <lcd_init+0x26>
 1f2:	00 00       	nop
    delay(LCD_DELAY_INIT);               /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
 1f4:	0e 94 5e 00 	call	0xbc	; 0xbc <toggle_e>
 1f8:	9e e4       	ldi	r25, 0x4E	; 78
 1fa:	9a 95       	dec	r25
 1fc:	f1 f7       	brne	.-4      	; 0x1fa <lcd_init+0x2e>
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <lcd_init+0x34>
    delay(LCD_DELAY_INIT_REP);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
 200:	0e 94 5e 00 	call	0xbc	; 0xbc <toggle_e>
 204:	8e e4       	ldi	r24, 0x4E	; 78
 206:	8a 95       	dec	r24
 208:	f1 f7       	brne	.-4      	; 0x206 <lcd_init+0x3a>
 20a:	00 c0       	rjmp	.+0      	; 0x20c <lcd_init+0x40>
    delay(LCD_DELAY_INIT_REP);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
 20c:	40 98       	cbi	0x08, 0	; 8
    lcd_e_toggle();
 20e:	0e 94 5e 00 	call	0xbc	; 0xbc <toggle_e>
 212:	9e e4       	ldi	r25, 0x4E	; 78
 214:	9a 95       	dec	r25
 216:	f1 f7       	brne	.-4      	; 0x214 <lcd_init+0x48>
 218:	00 c0       	rjmp	.+0      	; 0x21a <lcd_init+0x4e>
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 21a:	88 e2       	ldi	r24, 0x28	; 40
 21c:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
 220:	88 e0       	ldi	r24, 0x08	; 8
 222:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
 226:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 22a:	86 e0       	ldi	r24, 0x06	; 6
 22c:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
 230:	8c 2f       	mov	r24, r28
 232:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_command>

}/* lcd_init */
 236:	cf 91       	pop	r28
 238:	08 95       	ret

0000023a <init_lcd>:
void debugInput();
int main(void);


void init_lcd() {
	lcd_init(LCD_DISP_ON);
 23a:	8c e0       	ldi	r24, 0x0C	; 12
 23c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <lcd_init>
	lcd_clrscr();
 240:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_clrscr>
	lcd_puts(NAME_OF_BM);
 244:	80 e0       	ldi	r24, 0x00	; 0
 246:	91 e0       	ldi	r25, 0x01	; 1
 248:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	lcd_puts("\n");
 24c:	89 e0       	ldi	r24, 0x09	; 9
 24e:	91 e0       	ldi	r25, 0x01	; 1
 250:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	lcd_puts("LCD for debugging");
 254:	8b e0       	ldi	r24, 0x0B	; 11
 256:	91 e0       	ldi	r25, 0x01	; 1
 258:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
 25c:	08 95       	ret

0000025e <init_uart>:
}

void init_uart() {
	uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) );	
 25e:	87 e1       	ldi	r24, 0x17	; 23
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	0e 94 b0 04 	call	0x960	; 0x960 <uart_init>
 266:	08 95       	ret

00000268 <init_bluetooth>:
}

void init_bluetooth(){
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
 26c:	cd b7       	in	r28, 0x3d	; 61
 26e:	de b7       	in	r29, 0x3e	; 62
 270:	64 97       	sbiw	r28, 0x14	; 20
 272:	0f b6       	in	r0, 0x3f	; 63
 274:	f8 94       	cli
 276:	de bf       	out	0x3e, r29	; 62
 278:	0f be       	out	0x3f, r0	; 63
 27a:	cd bf       	out	0x3d, r28	; 61
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 27c:	2f ef       	ldi	r18, 0xFF	; 255
 27e:	8f e9       	ldi	r24, 0x9F	; 159
 280:	95 e0       	ldi	r25, 0x05	; 5
 282:	21 50       	subi	r18, 0x01	; 1
 284:	80 40       	sbci	r24, 0x00	; 0
 286:	90 40       	sbci	r25, 0x00	; 0
 288:	e1 f7       	brne	.-8      	; 0x282 <init_bluetooth+0x1a>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <init_bluetooth+0x24>
 28c:	00 00       	nop
	_delay_ms(500);
	uart_puts_P("$$$\r");
 28e:	89 e7       	ldi	r24, 0x79	; 121
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	0e 94 0b 05 	call	0xa16	; 0xa16 <uart_puts_p>
	uart_puts_P("+\r");
 296:	86 e7       	ldi	r24, 0x76	; 118
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	0e 94 0b 05 	call	0xa16	; 0xa16 <uart_puts_p>
 29e:	2f ef       	ldi	r18, 0xFF	; 255
 2a0:	8f e9       	ldi	r24, 0x9F	; 159
 2a2:	95 e0       	ldi	r25, 0x05	; 5
 2a4:	21 50       	subi	r18, 0x01	; 1
 2a6:	80 40       	sbci	r24, 0x00	; 0
 2a8:	90 40       	sbci	r25, 0x00	; 0
 2aa:	e1 f7       	brne	.-8      	; 0x2a4 <init_bluetooth+0x3c>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <init_bluetooth+0x46>
 2ae:	00 00       	nop
	_delay_ms(500);
	
	char renameString[20];
	strcpy(renameString, "sn,");
 2b0:	83 e7       	ldi	r24, 0x73	; 115
 2b2:	9e e6       	ldi	r25, 0x6E	; 110
 2b4:	9a 83       	std	Y+2, r25	; 0x02
 2b6:	89 83       	std	Y+1, r24	; 0x01
 2b8:	8c e2       	ldi	r24, 0x2C	; 44
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	9c 83       	std	Y+4, r25	; 0x04
 2be:	8b 83       	std	Y+3, r24	; 0x03
	strcat(renameString, NAME_OF_BM);
 2c0:	ce 01       	movw	r24, r28
 2c2:	01 96       	adiw	r24, 0x01	; 1
 2c4:	dc 01       	movw	r26, r24
 2c6:	0d 90       	ld	r0, X+
 2c8:	00 20       	and	r0, r0
 2ca:	e9 f7       	brne	.-6      	; 0x2c6 <init_bluetooth+0x5e>
 2cc:	11 97       	sbiw	r26, 0x01	; 1
 2ce:	29 e0       	ldi	r18, 0x09	; 9
 2d0:	e0 e0       	ldi	r30, 0x00	; 0
 2d2:	f1 e0       	ldi	r31, 0x01	; 1
 2d4:	01 90       	ld	r0, Z+
 2d6:	0d 92       	st	X+, r0
 2d8:	2a 95       	dec	r18
 2da:	e1 f7       	brne	.-8      	; 0x2d4 <init_bluetooth+0x6c>
	strcat(renameString, "\r");
 2dc:	fc 01       	movw	r30, r24
 2de:	01 90       	ld	r0, Z+
 2e0:	00 20       	and	r0, r0
 2e2:	e9 f7       	brne	.-6      	; 0x2de <init_bluetooth+0x76>
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	2d e0       	ldi	r18, 0x0D	; 13
 2e8:	30 e0       	ldi	r19, 0x00	; 0
 2ea:	31 83       	std	Z+1, r19	; 0x01
 2ec:	20 83       	st	Z, r18
	uart_puts(renameString);
 2ee:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <uart_puts>
 2f2:	2f ef       	ldi	r18, 0xFF	; 255
 2f4:	8f e9       	ldi	r24, 0x9F	; 159
 2f6:	95 e0       	ldi	r25, 0x05	; 5
 2f8:	21 50       	subi	r18, 0x01	; 1
 2fa:	80 40       	sbci	r24, 0x00	; 0
 2fc:	90 40       	sbci	r25, 0x00	; 0
 2fe:	e1 f7       	brne	.-8      	; 0x2f8 <init_bluetooth+0x90>
 300:	00 c0       	rjmp	.+0      	; 0x302 <init_bluetooth+0x9a>
 302:	00 00       	nop
	_delay_ms(500);
	
	uart_puts_P("\rR,1\r");
 304:	80 e7       	ldi	r24, 0x70	; 112
 306:	90 e0       	ldi	r25, 0x00	; 0
 308:	0e 94 0b 05 	call	0xa16	; 0xa16 <uart_puts_p>
 30c:	2f ef       	ldi	r18, 0xFF	; 255
 30e:	8f e9       	ldi	r24, 0x9F	; 159
 310:	95 e0       	ldi	r25, 0x05	; 5
 312:	21 50       	subi	r18, 0x01	; 1
 314:	80 40       	sbci	r24, 0x00	; 0
 316:	90 40       	sbci	r25, 0x00	; 0
 318:	e1 f7       	brne	.-8      	; 0x312 <init_bluetooth+0xaa>
 31a:	00 c0       	rjmp	.+0      	; 0x31c <init_bluetooth+0xb4>
 31c:	00 00       	nop
	_delay_ms(500);
}
 31e:	64 96       	adiw	r28, 0x14	; 20
 320:	0f b6       	in	r0, 0x3f	; 63
 322:	f8 94       	cli
 324:	de bf       	out	0x3e, r29	; 62
 326:	0f be       	out	0x3f, r0	; 63
 328:	cd bf       	out	0x3d, r28	; 61
 32a:	df 91       	pop	r29
 32c:	cf 91       	pop	r28
 32e:	08 95       	ret

00000330 <init_ADC>:

void init_ADC() {
	ADMUX |= (1<<REFS0) | (1<<MUX0);
 330:	ec e7       	ldi	r30, 0x7C	; 124
 332:	f0 e0       	ldi	r31, 0x00	; 0
 334:	80 81       	ld	r24, Z
 336:	81 64       	ori	r24, 0x41	; 65
 338:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADEN) | (1<<ADSC) | (1<<ADATE) | (1<<ADIF) | (1<<ADIE) | (1<<ADPS2) |  (1<<ADPS1);
 33a:	ea e7       	ldi	r30, 0x7A	; 122
 33c:	f0 e0       	ldi	r31, 0x00	; 0
 33e:	80 81       	ld	r24, Z
 340:	8e 6f       	ori	r24, 0xFE	; 254
 342:	80 83       	st	Z, r24
 344:	08 95       	ret

00000346 <init_PWM>:
}

void init_PWM() {
	DDRB = 0xFF; // output
 346:	8f ef       	ldi	r24, 0xFF	; 255
 348:	84 b9       	out	0x04, r24	; 4
	TCCR0A = (1<<COM0A1) | (1<<WGM00) | (1<<WGM01);
 34a:	83 e8       	ldi	r24, 0x83	; 131
 34c:	84 bd       	out	0x24, r24	; 36
	TIMSK0 = (1<<TOIE0);
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	OCR0A = (dutyCycle/100) * 255.0;
 354:	20 e0       	ldi	r18, 0x00	; 0
 356:	30 e0       	ldi	r19, 0x00	; 0
 358:	48 ec       	ldi	r20, 0xC8	; 200
 35a:	52 e4       	ldi	r21, 0x42	; 66
 35c:	60 91 7c 01 	lds	r22, 0x017C	; 0x80017c <__data_end>
 360:	70 91 7d 01 	lds	r23, 0x017D	; 0x80017d <__data_end+0x1>
 364:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <__data_end+0x2>
 368:	90 91 7f 01 	lds	r25, 0x017F	; 0x80017f <__data_end+0x3>
 36c:	0e 94 8a 05 	call	0xb14	; 0xb14 <__divsf3>
 370:	20 e0       	ldi	r18, 0x00	; 0
 372:	30 e0       	ldi	r19, 0x00	; 0
 374:	4f e7       	ldi	r20, 0x7F	; 127
 376:	53 e4       	ldi	r21, 0x43	; 67
 378:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 37c:	0e 94 03 06 	call	0xc06	; 0xc06 <__fixunssfsi>
 380:	67 bd       	out	0x27, r22	; 39
 382:	08 95       	ret

00000384 <isReceivedValueValid>:
}

bool isReceivedValueValid(unsigned int receivedValue) {
	if ( receivedValue & UART_FRAME_ERROR || receivedValue & UART_OVERRUN_ERROR || receivedValue & UART_BUFFER_OVERFLOW ) {
 384:	88 27       	eor	r24, r24
 386:	9a 71       	andi	r25, 0x1A	; 26
 388:	89 2b       	or	r24, r25
 38a:	31 f0       	breq	.+12     	; 0x398 <isReceivedValueValid+0x14>
		lcd_puts("UARTERR");
 38c:	8d e1       	ldi	r24, 0x1D	; 29
 38e:	91 e0       	ldi	r25, 0x01	; 1
 390:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
		return false;
 394:	80 e0       	ldi	r24, 0x00	; 0
 396:	08 95       	ret
	}
	return true;
 398:	81 e0       	ldi	r24, 0x01	; 1
}
 39a:	08 95       	ret

0000039c <outputAdcAndVoltAndLevelAndPwmOnLcd>:

void outputAdcAndVoltAndLevelAndPwmOnLcd() {	
 39c:	0f 93       	push	r16
 39e:	1f 93       	push	r17
 3a0:	cf 93       	push	r28
 3a2:	df 93       	push	r29
 3a4:	cd b7       	in	r28, 0x3d	; 61
 3a6:	de b7       	in	r29, 0x3e	; 62
 3a8:	e0 97       	sbiw	r28, 0x30	; 48
 3aa:	0f b6       	in	r0, 0x3f	; 63
 3ac:	f8 94       	cli
 3ae:	de bf       	out	0x3e, r29	; 62
 3b0:	0f be       	out	0x3f, r0	; 63
 3b2:	cd bf       	out	0x3d, r28	; 61
	lcd_clrscr();
 3b4:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_clrscr>
	
	lcd_gotoxy(0,0);
 3b8:	60 e0       	ldi	r22, 0x00	; 0
 3ba:	80 e0       	ldi	r24, 0x00	; 0
 3bc:	0e 94 b3 00 	call	0x166	; 0x166 <lcd_gotoxy>
	lcd_puts("ADC ");
 3c0:	85 e2       	ldi	r24, 0x25	; 37
 3c2:	91 e0       	ldi	r25, 0x01	; 1
 3c4:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	char adcChar[16];
	itoa( ADC , adcChar, 10);
 3c8:	08 e7       	ldi	r16, 0x78	; 120
 3ca:	10 e0       	ldi	r17, 0x00	; 0
 3cc:	f8 01       	movw	r30, r16
 3ce:	80 81       	ld	r24, Z
 3d0:	91 81       	ldd	r25, Z+1	; 0x01
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 3d2:	4a e0       	ldi	r20, 0x0A	; 10
 3d4:	be 01       	movw	r22, r28
 3d6:	6f 5f       	subi	r22, 0xFF	; 255
 3d8:	7f 4f       	sbci	r23, 0xFF	; 255
 3da:	0e 94 56 07 	call	0xeac	; 0xeac <__itoa_ncheck>
	lcd_puts(adcChar);
 3de:	ce 01       	movw	r24, r28
 3e0:	01 96       	adiw	r24, 0x01	; 1
 3e2:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	
	lcd_gotoxy(8,0);
 3e6:	60 e0       	ldi	r22, 0x00	; 0
 3e8:	88 e0       	ldi	r24, 0x08	; 8
 3ea:	0e 94 b3 00 	call	0x166	; 0x166 <lcd_gotoxy>
	float volt = ((((float)ADC)*4.0)/1024)*1000;
 3ee:	f8 01       	movw	r30, r16
 3f0:	00 81       	ld	r16, Z
 3f2:	11 81       	ldd	r17, Z+1	; 0x01
	lcd_puts("mV ");
 3f4:	8a e2       	ldi	r24, 0x2A	; 42
 3f6:	91 e0       	ldi	r25, 0x01	; 1
 3f8:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
 3fc:	b8 01       	movw	r22, r16
 3fe:	80 e0       	ldi	r24, 0x00	; 0
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	0e 94 32 06 	call	0xc64	; 0xc64 <__floatunsisf>
 406:	20 e0       	ldi	r18, 0x00	; 0
 408:	30 e0       	ldi	r19, 0x00	; 0
 40a:	40 e8       	ldi	r20, 0x80	; 128
 40c:	50 e4       	ldi	r21, 0x40	; 64
 40e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 412:	20 e0       	ldi	r18, 0x00	; 0
 414:	30 e0       	ldi	r19, 0x00	; 0
 416:	40 e8       	ldi	r20, 0x80	; 128
 418:	5a e3       	ldi	r21, 0x3A	; 58
 41a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 41e:	20 e0       	ldi	r18, 0x00	; 0
 420:	30 e0       	ldi	r19, 0x00	; 0
 422:	4a e7       	ldi	r20, 0x7A	; 122
 424:	54 e4       	ldi	r21, 0x44	; 68
 426:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 42a:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <__fixsfsi>
 42e:	dc 01       	movw	r26, r24
 430:	cb 01       	movw	r24, r22
 432:	4a e0       	ldi	r20, 0x0A	; 10
 434:	be 01       	movw	r22, r28
 436:	6f 5e       	subi	r22, 0xEF	; 239
 438:	7f 4f       	sbci	r23, 0xFF	; 255
 43a:	0e 94 56 07 	call	0xeac	; 0xeac <__itoa_ncheck>
	char voltChar[16];
	itoa( volt , voltChar, 10);
	lcd_puts(voltChar);
 43e:	ce 01       	movw	r24, r28
 440:	41 96       	adiw	r24, 0x11	; 17
 442:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	
	lcd_gotoxy(0,1);
 446:	61 e0       	ldi	r22, 0x01	; 1
 448:	80 e0       	ldi	r24, 0x00	; 0
 44a:	0e 94 b3 00 	call	0x166	; 0x166 <lcd_gotoxy>
	lcd_puts("Level ");
 44e:	8e e2       	ldi	r24, 0x2E	; 46
 450:	91 e0       	ldi	r25, 0x01	; 1
 452:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	lcd_puts(level);
 456:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <level>
 45a:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <level+0x1>
 45e:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
	
	lcd_gotoxy(8,1);
 462:	61 e0       	ldi	r22, 0x01	; 1
 464:	88 e0       	ldi	r24, 0x08	; 8
 466:	0e 94 b3 00 	call	0x166	; 0x166 <lcd_gotoxy>
	lcd_puts("PWM ");
 46a:	85 e3       	ldi	r24, 0x35	; 53
 46c:	91 e0       	ldi	r25, 0x01	; 1
 46e:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
 472:	4a e0       	ldi	r20, 0x0A	; 10
 474:	be 01       	movw	r22, r28
 476:	6f 5d       	subi	r22, 0xDF	; 223
 478:	7f 4f       	sbci	r23, 0xFF	; 255
 47a:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <pwm>
 47e:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <pwm+0x1>
 482:	0e 94 56 07 	call	0xeac	; 0xeac <__itoa_ncheck>
	char pwmChar[16];
	itoa( pwm , pwmChar, 10);
	lcd_puts(pwmChar);
 486:	ce 01       	movw	r24, r28
 488:	81 96       	adiw	r24, 0x21	; 33
 48a:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_puts>
}
 48e:	e0 96       	adiw	r28, 0x30	; 48
 490:	0f b6       	in	r0, 0x3f	; 63
 492:	f8 94       	cli
 494:	de bf       	out	0x3e, r29	; 62
 496:	0f be       	out	0x3f, r0	; 63
 498:	cd bf       	out	0x3d, r28	; 61
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	1f 91       	pop	r17
 4a0:	0f 91       	pop	r16
 4a2:	08 95       	ret

000004a4 <serialSend>:
		default:
			return;
	}
}

void serialSend(char* sendString){
 4a4:	cf 93       	push	r28
 4a6:	df 93       	push	r29
 4a8:	ec 01       	movw	r28, r24
 4aa:	ac 01       	movw	r20, r24
	for (int i = 0; i < strlen(sendString); i++){
 4ac:	20 e0       	ldi	r18, 0x00	; 0
 4ae:	30 e0       	ldi	r19, 0x00	; 0
		while (( UCSR0A & (1<<UDRE0))  == 0){};
 4b0:	e0 ec       	ldi	r30, 0xC0	; 192
 4b2:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = sendString[i];
 4b4:	66 ec       	ldi	r22, 0xC6	; 198
 4b6:	70 e0       	ldi	r23, 0x00	; 0
			return;
	}
}

void serialSend(char* sendString){
	for (int i = 0; i < strlen(sendString); i++){
 4b8:	0a c0       	rjmp	.+20     	; 0x4ce <serialSend+0x2a>
		while (( UCSR0A & (1<<UDRE0))  == 0){};
 4ba:	90 81       	ld	r25, Z
 4bc:	95 ff       	sbrs	r25, 5
 4be:	fd cf       	rjmp	.-6      	; 0x4ba <serialSend+0x16>
		UDR0 = sendString[i];
 4c0:	da 01       	movw	r26, r20
 4c2:	8d 91       	ld	r24, X+
 4c4:	ad 01       	movw	r20, r26
 4c6:	db 01       	movw	r26, r22
 4c8:	8c 93       	st	X, r24
			return;
	}
}

void serialSend(char* sendString){
	for (int i = 0; i < strlen(sendString); i++){
 4ca:	2f 5f       	subi	r18, 0xFF	; 255
 4cc:	3f 4f       	sbci	r19, 0xFF	; 255
 4ce:	de 01       	movw	r26, r28
 4d0:	0d 90       	ld	r0, X+
 4d2:	00 20       	and	r0, r0
 4d4:	e9 f7       	brne	.-6      	; 0x4d0 <serialSend+0x2c>
 4d6:	11 97       	sbiw	r26, 0x01	; 1
 4d8:	ac 1b       	sub	r26, r28
 4da:	bd 0b       	sbc	r27, r29
 4dc:	2a 17       	cp	r18, r26
 4de:	3b 07       	cpc	r19, r27
 4e0:	60 f3       	brcs	.-40     	; 0x4ba <serialSend+0x16>
		while (( UCSR0A & (1<<UDRE0))  == 0){};
		UDR0 = sendString[i];
	}
}
 4e2:	df 91       	pop	r29
 4e4:	cf 91       	pop	r28
 4e6:	08 95       	ret

000004e8 <setLevel>:
	itoa( pwm , pwmChar, 10);
	lcd_puts(pwmChar);
}

void setLevel(char value) {	
	switch (value) {
 4e8:	82 33       	cpi	r24, 0x32	; 50
 4ea:	71 f1       	breq	.+92     	; 0x548 <setLevel+0x60>
 4ec:	28 f4       	brcc	.+10     	; 0x4f8 <setLevel+0x10>
 4ee:	80 33       	cpi	r24, 0x30	; 48
 4f0:	59 f0       	breq	.+22     	; 0x508 <setLevel+0x20>
 4f2:	81 33       	cpi	r24, 0x31	; 49
 4f4:	c1 f0       	breq	.+48     	; 0x526 <setLevel+0x3e>
 4f6:	08 95       	ret
 4f8:	84 33       	cpi	r24, 0x34	; 52
 4fa:	09 f4       	brne	.+2      	; 0x4fe <setLevel+0x16>
 4fc:	47 c0       	rjmp	.+142    	; 0x58c <setLevel+0xa4>
 4fe:	a8 f1       	brcs	.+106    	; 0x56a <setLevel+0x82>
 500:	85 33       	cpi	r24, 0x35	; 53
 502:	09 f4       	brne	.+2      	; 0x506 <setLevel+0x1e>
 504:	54 c0       	rjmp	.+168    	; 0x5ae <setLevel+0xc6>
 506:	08 95       	ret
		case LEVEL0IN:
			level = "0";
 508:	8a e3       	ldi	r24, 0x3A	; 58
 50a:	91 e0       	ldi	r25, 0x01	; 1
 50c:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <level+0x1>
 510:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <level>
			lvl = 0;
 514:	10 92 c6 01 	sts	0x01C6, r1	; 0x8001c6 <lvl+0x1>
 518:	10 92 c5 01 	sts	0x01C5, r1	; 0x8001c5 <lvl>
			serialSend("L0L");
 51c:	8c e3       	ldi	r24, 0x3C	; 60
 51e:	91 e0       	ldi	r25, 0x01	; 1
 520:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
			break;
 524:	08 95       	ret
		case LEVEL1IN:
			level = "1";
 526:	80 e4       	ldi	r24, 0x40	; 64
 528:	91 e0       	ldi	r25, 0x01	; 1
 52a:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <level+0x1>
 52e:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <level>
			lvl = 1;
 532:	81 e0       	ldi	r24, 0x01	; 1
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <lvl+0x1>
 53a:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <lvl>
			serialSend("L1L");
 53e:	82 e4       	ldi	r24, 0x42	; 66
 540:	91 e0       	ldi	r25, 0x01	; 1
 542:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
			break;
 546:	08 95       	ret
		case LEVEL2IN:
			level = "2";
 548:	86 e4       	ldi	r24, 0x46	; 70
 54a:	91 e0       	ldi	r25, 0x01	; 1
 54c:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <level+0x1>
 550:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <level>
			lvl = 2;
 554:	82 e0       	ldi	r24, 0x02	; 2
 556:	90 e0       	ldi	r25, 0x00	; 0
 558:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <lvl+0x1>
 55c:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <lvl>
			serialSend("L2L");
 560:	88 e4       	ldi	r24, 0x48	; 72
 562:	91 e0       	ldi	r25, 0x01	; 1
 564:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
			break;
 568:	08 95       	ret
		case LEVEL3IN:
			level = "3";
 56a:	8c e4       	ldi	r24, 0x4C	; 76
 56c:	91 e0       	ldi	r25, 0x01	; 1
 56e:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <level+0x1>
 572:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <level>
			lvl = 3;
 576:	83 e0       	ldi	r24, 0x03	; 3
 578:	90 e0       	ldi	r25, 0x00	; 0
 57a:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <lvl+0x1>
 57e:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <lvl>
			serialSend("L3L");
 582:	8e e4       	ldi	r24, 0x4E	; 78
 584:	91 e0       	ldi	r25, 0x01	; 1
 586:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
			break;
 58a:	08 95       	ret
		case LEVEL4IN:
			level = "4";
 58c:	82 e5       	ldi	r24, 0x52	; 82
 58e:	91 e0       	ldi	r25, 0x01	; 1
 590:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <level+0x1>
 594:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <level>
			lvl = 4;
 598:	84 e0       	ldi	r24, 0x04	; 4
 59a:	90 e0       	ldi	r25, 0x00	; 0
 59c:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <lvl+0x1>
 5a0:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <lvl>
			serialSend("L4L");
 5a4:	84 e5       	ldi	r24, 0x54	; 84
 5a6:	91 e0       	ldi	r25, 0x01	; 1
 5a8:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
			break;
 5ac:	08 95       	ret
		case LEVEL5IN:
			level = "5";
 5ae:	88 e5       	ldi	r24, 0x58	; 88
 5b0:	91 e0       	ldi	r25, 0x01	; 1
 5b2:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <level+0x1>
 5b6:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <level>
			lvl = 5;
 5ba:	85 e0       	ldi	r24, 0x05	; 5
 5bc:	90 e0       	ldi	r25, 0x00	; 0
 5be:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <lvl+0x1>
 5c2:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <lvl>
			serialSend("L5L");
 5c6:	8a e5       	ldi	r24, 0x5A	; 90
 5c8:	91 e0       	ldi	r25, 0x01	; 1
 5ca:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
 5ce:	08 95       	ret

000005d0 <debugInput>:
		UDR0 = sendString[i];
	}
}

void debugInput(){
	if(!(PINA & _BV(PINA2))) {
 5d0:	02 99       	sbic	0x00, 2	; 0
 5d2:	10 c0       	rjmp	.+32     	; 0x5f4 <debugInput+0x24>
		setLevel(0b00110000);
 5d4:	80 e3       	ldi	r24, 0x30	; 48
 5d6:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
 5da:	2f ef       	ldi	r18, 0xFF	; 255
 5dc:	8f e9       	ldi	r24, 0x9F	; 159
 5de:	95 e0       	ldi	r25, 0x05	; 5
 5e0:	21 50       	subi	r18, 0x01	; 1
 5e2:	80 40       	sbci	r24, 0x00	; 0
 5e4:	90 40       	sbci	r25, 0x00	; 0
 5e6:	e1 f7       	brne	.-8      	; 0x5e0 <debugInput+0x10>
 5e8:	00 c0       	rjmp	.+0      	; 0x5ea <debugInput+0x1a>
 5ea:	00 00       	nop
		_delay_ms(500);
		serialSend("T12T");
 5ec:	8e e5       	ldi	r24, 0x5E	; 94
 5ee:	91 e0       	ldi	r25, 0x01	; 1
 5f0:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
	}
	if(!(PINA & _BV(PINA3))) {
 5f4:	03 99       	sbic	0x00, 3	; 0
 5f6:	10 c0       	rjmp	.+32     	; 0x618 <debugInput+0x48>
		setLevel(0b00110001);
 5f8:	81 e3       	ldi	r24, 0x31	; 49
 5fa:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
 5fe:	2f ef       	ldi	r18, 0xFF	; 255
 600:	8f e9       	ldi	r24, 0x9F	; 159
 602:	95 e0       	ldi	r25, 0x05	; 5
 604:	21 50       	subi	r18, 0x01	; 1
 606:	80 40       	sbci	r24, 0x00	; 0
 608:	90 40       	sbci	r25, 0x00	; 0
 60a:	e1 f7       	brne	.-8      	; 0x604 <debugInput+0x34>
 60c:	00 c0       	rjmp	.+0      	; 0x60e <debugInput+0x3e>
 60e:	00 00       	nop
		_delay_ms(500);
		serialSend("T24T");
 610:	83 e6       	ldi	r24, 0x63	; 99
 612:	91 e0       	ldi	r25, 0x01	; 1
 614:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
	}
	if(!(PINA & _BV(PINA4))) {
 618:	04 99       	sbic	0x00, 4	; 0
 61a:	10 c0       	rjmp	.+32     	; 0x63c <debugInput+0x6c>
		setLevel(0b00110010);
 61c:	82 e3       	ldi	r24, 0x32	; 50
 61e:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
 622:	2f ef       	ldi	r18, 0xFF	; 255
 624:	8f e9       	ldi	r24, 0x9F	; 159
 626:	95 e0       	ldi	r25, 0x05	; 5
 628:	21 50       	subi	r18, 0x01	; 1
 62a:	80 40       	sbci	r24, 0x00	; 0
 62c:	90 40       	sbci	r25, 0x00	; 0
 62e:	e1 f7       	brne	.-8      	; 0x628 <debugInput+0x58>
 630:	00 c0       	rjmp	.+0      	; 0x632 <debugInput+0x62>
 632:	00 00       	nop
		_delay_ms(500);
		serialSend("T35T");
 634:	88 e6       	ldi	r24, 0x68	; 104
 636:	91 e0       	ldi	r25, 0x01	; 1
 638:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
	}
	if(!(PINA & _BV(PINA5))) {
 63c:	05 99       	sbic	0x00, 5	; 0
 63e:	10 c0       	rjmp	.+32     	; 0x660 <debugInput+0x90>
		setLevel(0b00110011);
 640:	83 e3       	ldi	r24, 0x33	; 51
 642:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
 646:	2f ef       	ldi	r18, 0xFF	; 255
 648:	8f e9       	ldi	r24, 0x9F	; 159
 64a:	95 e0       	ldi	r25, 0x05	; 5
 64c:	21 50       	subi	r18, 0x01	; 1
 64e:	80 40       	sbci	r24, 0x00	; 0
 650:	90 40       	sbci	r25, 0x00	; 0
 652:	e1 f7       	brne	.-8      	; 0x64c <debugInput+0x7c>
 654:	00 c0       	rjmp	.+0      	; 0x656 <debugInput+0x86>
 656:	00 00       	nop
		_delay_ms(500);
		serialSend("B99B");
 658:	8d e6       	ldi	r24, 0x6D	; 109
 65a:	91 e0       	ldi	r25, 0x01	; 1
 65c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
	}
	if(!(PINA & _BV(PINA6))) {
 660:	06 99       	sbic	0x00, 6	; 0
 662:	10 c0       	rjmp	.+32     	; 0x684 <debugInput+0xb4>
		setLevel(0b00110100);
 664:	84 e3       	ldi	r24, 0x34	; 52
 666:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
 66a:	2f ef       	ldi	r18, 0xFF	; 255
 66c:	8f e9       	ldi	r24, 0x9F	; 159
 66e:	95 e0       	ldi	r25, 0x05	; 5
 670:	21 50       	subi	r18, 0x01	; 1
 672:	80 40       	sbci	r24, 0x00	; 0
 674:	90 40       	sbci	r25, 0x00	; 0
 676:	e1 f7       	brne	.-8      	; 0x670 <debugInput+0xa0>
 678:	00 c0       	rjmp	.+0      	; 0x67a <debugInput+0xaa>
 67a:	00 00       	nop
		_delay_ms(500);
		serialSend("B78B");
 67c:	82 e7       	ldi	r24, 0x72	; 114
 67e:	91 e0       	ldi	r25, 0x01	; 1
 680:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
	}
	if(!(PINA & _BV(PINA7))) {
 684:	07 99       	sbic	0x00, 7	; 0
 686:	10 c0       	rjmp	.+32     	; 0x6a8 <debugInput+0xd8>
		setLevel(0b00110101);
 688:	85 e3       	ldi	r24, 0x35	; 53
 68a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
 68e:	2f ef       	ldi	r18, 0xFF	; 255
 690:	8f e9       	ldi	r24, 0x9F	; 159
 692:	95 e0       	ldi	r25, 0x05	; 5
 694:	21 50       	subi	r18, 0x01	; 1
 696:	80 40       	sbci	r24, 0x00	; 0
 698:	90 40       	sbci	r25, 0x00	; 0
 69a:	e1 f7       	brne	.-8      	; 0x694 <debugInput+0xc4>
 69c:	00 c0       	rjmp	.+0      	; 0x69e <debugInput+0xce>
 69e:	00 00       	nop
		_delay_ms(500);
		serialSend("B32B");
 6a0:	87 e7       	ldi	r24, 0x77	; 119
 6a2:	91 e0       	ldi	r25, 0x01	; 1
 6a4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <serialSend>
 6a8:	08 95       	ret

000006aa <main>:
	}
}

int main(void) {
	DDRA = 0x00; // cheat
 6aa:	11 b8       	out	0x01, r1	; 1
	
	init_lcd();
 6ac:	0e 94 1d 01 	call	0x23a	; 0x23a <init_lcd>
	init_uart();
 6b0:	0e 94 2f 01 	call	0x25e	; 0x25e <init_uart>
	init_bluetooth();
 6b4:	0e 94 34 01 	call	0x268	; 0x268 <init_bluetooth>
	init_PWM();
 6b8:	0e 94 a3 01 	call	0x346	; 0x346 <init_PWM>
	init_ADC();
 6bc:	0e 94 98 01 	call	0x330	; 0x330 <init_ADC>
		
	TCCR0B =  (1<<CS00); //| (1<<CS01) ;//(1<<CS02); 
 6c0:	81 e0       	ldi	r24, 0x01	; 1
 6c2:	85 bd       	out	0x25, r24	; 37
	sei(); // set external interrupts - has to be done last
 6c4:	78 94       	sei
	
	unsigned int valueReceivedViaBT;
	unsigned char cachedValue = 0b11111111;
 6c6:	77 24       	eor	r7, r7
 6c8:	7a 94       	dec	r7
				setLevel(cachedValue);
			}
		}
		
		
		float volt = (((float)ADC)*4.0)/1024;
 6ca:	c8 e7       	ldi	r28, 0x78	; 120
 6cc:	d0 e0       	ldi	r29, 0x00	; 0
		float celcius = 701.41*volt*volt*volt - 2838.1*volt*volt + 3839*volt - 1700.1;
		int maxTempNotReached = 1;
 6ce:	11 e0       	ldi	r17, 0x01	; 1
 6d0:	61 2c       	mov	r6, r1
 6d2:	55 24       	eor	r5, r5
 6d4:	53 94       	inc	r5
 6d6:	41 2c       	mov	r4, r1
					maxTempNotReached = 1;
				}
				break;
		}
		
		pwm = lvl * 51 * maxTempNotReached;
 6d8:	03 e3       	ldi	r16, 0x33	; 51
	
	unsigned int valueReceivedViaBT;
	unsigned char cachedValue = 0b11111111;
	
    while (1) {
	    debugInput();	// cheat
 6da:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <debugInput>
		
        valueReceivedViaBT = uart_getc();
 6de:	0e 94 c9 04 	call	0x992	; 0x992 <uart_getc>
 6e2:	7c 01       	movw	r14, r24
		if ( valueReceivedViaBT & UART_NO_DATA) {
 6e4:	90 fd       	sbrc	r25, 0
 6e6:	0d c0       	rjmp	.+26     	; 0x702 <main+0x58>
			// no data available from UART
		} else {
			isReceivedValueValid(valueReceivedViaBT); // no need to do that
 6e8:	0e 94 c2 01 	call	0x384	; 0x384 <isReceivedValueValid>
			
			if (cachedValue != (unsigned char) valueReceivedViaBT) {
 6ec:	87 2d       	mov	r24, r7
 6ee:	90 e0       	ldi	r25, 0x00	; 0
 6f0:	97 01       	movw	r18, r14
 6f2:	33 27       	eor	r19, r19
 6f4:	82 17       	cp	r24, r18
 6f6:	93 07       	cpc	r25, r19
 6f8:	21 f0       	breq	.+8      	; 0x702 <main+0x58>
				cachedValue = (unsigned char) valueReceivedViaBT;
 6fa:	7e 2c       	mov	r7, r14
				setLevel(cachedValue);
 6fc:	8e 2d       	mov	r24, r14
 6fe:	0e 94 74 02 	call	0x4e8	; 0x4e8 <setLevel>
			}
		}
		
		
		float volt = (((float)ADC)*4.0)/1024;
 702:	68 81       	ld	r22, Y
 704:	79 81       	ldd	r23, Y+1	; 0x01
 706:	80 e0       	ldi	r24, 0x00	; 0
 708:	90 e0       	ldi	r25, 0x00	; 0
 70a:	0e 94 32 06 	call	0xc64	; 0xc64 <__floatunsisf>
 70e:	20 e0       	ldi	r18, 0x00	; 0
 710:	30 e0       	ldi	r19, 0x00	; 0
 712:	40 e8       	ldi	r20, 0x80	; 128
 714:	50 e4       	ldi	r21, 0x40	; 64
 716:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 71a:	20 e0       	ldi	r18, 0x00	; 0
 71c:	30 e0       	ldi	r19, 0x00	; 0
 71e:	40 e8       	ldi	r20, 0x80	; 128
 720:	5a e3       	ldi	r21, 0x3A	; 58
 722:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 726:	6b 01       	movw	r12, r22
 728:	7c 01       	movw	r14, r24
		float celcius = 701.41*volt*volt*volt - 2838.1*volt*volt + 3839*volt - 1700.1;
 72a:	2d e3       	ldi	r18, 0x3D	; 61
 72c:	3a e5       	ldi	r19, 0x5A	; 90
 72e:	4f e2       	ldi	r20, 0x2F	; 47
 730:	54 e4       	ldi	r21, 0x44	; 68
 732:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 736:	a7 01       	movw	r20, r14
 738:	96 01       	movw	r18, r12
 73a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 73e:	a7 01       	movw	r20, r14
 740:	96 01       	movw	r18, r12
 742:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 746:	4b 01       	movw	r8, r22
 748:	5c 01       	movw	r10, r24
 74a:	2a e9       	ldi	r18, 0x9A	; 154
 74c:	31 e6       	ldi	r19, 0x61	; 97
 74e:	41 e3       	ldi	r20, 0x31	; 49
 750:	55 e4       	ldi	r21, 0x45	; 69
 752:	c7 01       	movw	r24, r14
 754:	b6 01       	movw	r22, r12
 756:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 75a:	a7 01       	movw	r20, r14
 75c:	96 01       	movw	r18, r12
 75e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 762:	9b 01       	movw	r18, r22
 764:	ac 01       	movw	r20, r24
 766:	c5 01       	movw	r24, r10
 768:	b4 01       	movw	r22, r8
 76a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <__subsf3>
 76e:	4b 01       	movw	r8, r22
 770:	5c 01       	movw	r10, r24
 772:	20 e0       	ldi	r18, 0x00	; 0
 774:	30 ef       	ldi	r19, 0xF0	; 240
 776:	4f e6       	ldi	r20, 0x6F	; 111
 778:	55 e4       	ldi	r21, 0x45	; 69
 77a:	c7 01       	movw	r24, r14
 77c:	b6 01       	movw	r22, r12
 77e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <__mulsf3>
 782:	9b 01       	movw	r18, r22
 784:	ac 01       	movw	r20, r24
 786:	c5 01       	movw	r24, r10
 788:	b4 01       	movw	r22, r8
 78a:	0e 94 1e 05 	call	0xa3c	; 0xa3c <__addsf3>
 78e:	23 e3       	ldi	r18, 0x33	; 51
 790:	33 e8       	ldi	r19, 0x83	; 131
 792:	44 ed       	ldi	r20, 0xD4	; 212
 794:	54 e4       	ldi	r21, 0x44	; 68
 796:	0e 94 1d 05 	call	0xa3a	; 0xa3a <__subsf3>
		int maxTempNotReached = 1;
		
		switch (lvl) {
 79a:	e0 90 c5 01 	lds	r14, 0x01C5	; 0x8001c5 <lvl>
 79e:	f0 90 c6 01 	lds	r15, 0x01C6	; 0x8001c6 <lvl+0x1>
 7a2:	23 e0       	ldi	r18, 0x03	; 3
 7a4:	e2 16       	cp	r14, r18
 7a6:	f1 04       	cpc	r15, r1
 7a8:	79 f1       	breq	.+94     	; 0x808 <main+0x15e>
 7aa:	4c f4       	brge	.+18     	; 0x7be <main+0x114>
 7ac:	21 e0       	ldi	r18, 0x01	; 1
 7ae:	e2 16       	cp	r14, r18
 7b0:	f1 04       	cpc	r15, r1
 7b2:	71 f0       	breq	.+28     	; 0x7d0 <main+0x126>
 7b4:	22 e0       	ldi	r18, 0x02	; 2
 7b6:	e2 16       	cp	r14, r18
 7b8:	f1 04       	cpc	r15, r1
 7ba:	c1 f0       	breq	.+48     	; 0x7ec <main+0x142>
 7bc:	4f c0       	rjmp	.+158    	; 0x85c <main+0x1b2>
 7be:	24 e0       	ldi	r18, 0x04	; 4
 7c0:	e2 16       	cp	r14, r18
 7c2:	f1 04       	cpc	r15, r1
 7c4:	79 f1       	breq	.+94     	; 0x824 <main+0x17a>
 7c6:	25 e0       	ldi	r18, 0x05	; 5
 7c8:	e2 16       	cp	r14, r18
 7ca:	f1 04       	cpc	r15, r1
 7cc:	c9 f1       	breq	.+114    	; 0x840 <main+0x196>
 7ce:	46 c0       	rjmp	.+140    	; 0x85c <main+0x1b2>
		}
		
		
		float volt = (((float)ADC)*4.0)/1024;
		float celcius = 701.41*volt*volt*volt - 2838.1*volt*volt + 3839*volt - 1700.1;
		int maxTempNotReached = 1;
 7d0:	d1 2e       	mov	r13, r17
 7d2:	20 e0       	ldi	r18, 0x00	; 0
 7d4:	30 e0       	ldi	r19, 0x00	; 0
 7d6:	48 ec       	ldi	r20, 0xC8	; 200
 7d8:	51 e4       	ldi	r21, 0x41	; 65
 7da:	0e 94 c0 06 	call	0xd80	; 0xd80 <__gesf2>
 7de:	18 16       	cp	r1, r24
 7e0:	0c f0       	brlt	.+2      	; 0x7e4 <main+0x13a>
 7e2:	d6 2c       	mov	r13, r6
 7e4:	d1 26       	eor	r13, r17
 7e6:	8d 2d       	mov	r24, r13
 7e8:	90 e0       	ldi	r25, 0x00	; 0
 7ea:	3a c0       	rjmp	.+116    	; 0x860 <main+0x1b6>
 7ec:	d1 2e       	mov	r13, r17
 7ee:	20 e0       	ldi	r18, 0x00	; 0
 7f0:	30 e0       	ldi	r19, 0x00	; 0
 7f2:	4c e0       	ldi	r20, 0x0C	; 12
 7f4:	52 e4       	ldi	r21, 0x42	; 66
 7f6:	0e 94 c0 06 	call	0xd80	; 0xd80 <__gesf2>
 7fa:	18 16       	cp	r1, r24
 7fc:	0c f0       	brlt	.+2      	; 0x800 <main+0x156>
 7fe:	d6 2c       	mov	r13, r6
 800:	d1 26       	eor	r13, r17
 802:	8d 2d       	mov	r24, r13
 804:	90 e0       	ldi	r25, 0x00	; 0
 806:	2c c0       	rjmp	.+88     	; 0x860 <main+0x1b6>
 808:	d1 2e       	mov	r13, r17
 80a:	20 e0       	ldi	r18, 0x00	; 0
 80c:	30 e0       	ldi	r19, 0x00	; 0
 80e:	40 e2       	ldi	r20, 0x20	; 32
 810:	52 e4       	ldi	r21, 0x42	; 66
 812:	0e 94 c0 06 	call	0xd80	; 0xd80 <__gesf2>
 816:	18 16       	cp	r1, r24
 818:	0c f0       	brlt	.+2      	; 0x81c <main+0x172>
 81a:	d6 2c       	mov	r13, r6
 81c:	d1 26       	eor	r13, r17
 81e:	8d 2d       	mov	r24, r13
 820:	90 e0       	ldi	r25, 0x00	; 0
 822:	1e c0       	rjmp	.+60     	; 0x860 <main+0x1b6>
 824:	d1 2e       	mov	r13, r17
 826:	20 e0       	ldi	r18, 0x00	; 0
 828:	30 e0       	ldi	r19, 0x00	; 0
 82a:	44 e3       	ldi	r20, 0x34	; 52
 82c:	52 e4       	ldi	r21, 0x42	; 66
 82e:	0e 94 c0 06 	call	0xd80	; 0xd80 <__gesf2>
 832:	18 16       	cp	r1, r24
 834:	0c f0       	brlt	.+2      	; 0x838 <main+0x18e>
 836:	d6 2c       	mov	r13, r6
 838:	d1 26       	eor	r13, r17
 83a:	8d 2d       	mov	r24, r13
 83c:	90 e0       	ldi	r25, 0x00	; 0
 83e:	10 c0       	rjmp	.+32     	; 0x860 <main+0x1b6>
 840:	d1 2e       	mov	r13, r17
 842:	20 e0       	ldi	r18, 0x00	; 0
 844:	30 e0       	ldi	r19, 0x00	; 0
 846:	4c e5       	ldi	r20, 0x5C	; 92
 848:	52 e4       	ldi	r21, 0x42	; 66
 84a:	0e 94 c0 06 	call	0xd80	; 0xd80 <__gesf2>
 84e:	18 16       	cp	r1, r24
 850:	0c f0       	brlt	.+2      	; 0x854 <main+0x1aa>
 852:	d6 2c       	mov	r13, r6
 854:	d1 26       	eor	r13, r17
 856:	8d 2d       	mov	r24, r13
 858:	90 e0       	ldi	r25, 0x00	; 0
 85a:	02 c0       	rjmp	.+4      	; 0x860 <main+0x1b6>
 85c:	85 2d       	mov	r24, r5
 85e:	94 2d       	mov	r25, r4
					maxTempNotReached = 1;
				}
				break;
		}
		
		pwm = lvl * 51 * maxTempNotReached;
 860:	0e 9d       	mul	r16, r14
 862:	a0 01       	movw	r20, r0
 864:	0f 9d       	mul	r16, r15
 866:	50 0d       	add	r21, r0
 868:	11 24       	eor	r1, r1
 86a:	48 9f       	mul	r20, r24
 86c:	90 01       	movw	r18, r0
 86e:	49 9f       	mul	r20, r25
 870:	30 0d       	add	r19, r0
 872:	58 9f       	mul	r21, r24
 874:	30 0d       	add	r19, r0
 876:	11 24       	eor	r1, r1
 878:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <pwm+0x1>
 87c:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <pwm>
		
		OCR0A = pwm;	
 880:	27 bd       	out	0x27, r18	; 39
		outputAdcAndVoltAndLevelAndPwmOnLcd();
 882:	0e 94 ce 01 	call	0x39c	; 0x39c <outputAdcAndVoltAndLevelAndPwmOnLcd>
    }
 886:	29 cf       	rjmp	.-430    	; 0x6da <main+0x30>

00000888 <__vector_18>:
}

//Interrupts
ISR (TIMER0_OVF_vect) {
 888:	1f 92       	push	r1
 88a:	0f 92       	push	r0
 88c:	0f b6       	in	r0, 0x3f	; 63
 88e:	0f 92       	push	r0
 890:	11 24       	eor	r1, r1

}
 892:	0f 90       	pop	r0
 894:	0f be       	out	0x3f, r0	; 63
 896:	0f 90       	pop	r0
 898:	1f 90       	pop	r1
 89a:	18 95       	reti

0000089c <__vector_24>:

ISR (ADC_vect) {
 89c:	1f 92       	push	r1
 89e:	0f 92       	push	r0
 8a0:	0f b6       	in	r0, 0x3f	; 63
 8a2:	0f 92       	push	r0
 8a4:	11 24       	eor	r1, r1

}
 8a6:	0f 90       	pop	r0
 8a8:	0f be       	out	0x3f, r0	; 63
 8aa:	0f 90       	pop	r0
 8ac:	1f 90       	pop	r1
 8ae:	18 95       	reti

000008b0 <__vector_20>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
 8b0:	1f 92       	push	r1
 8b2:	0f 92       	push	r0
 8b4:	0f b6       	in	r0, 0x3f	; 63
 8b6:	0f 92       	push	r0
 8b8:	11 24       	eor	r1, r1
 8ba:	2f 93       	push	r18
 8bc:	8f 93       	push	r24
 8be:	9f 93       	push	r25
 8c0:	ef 93       	push	r30
 8c2:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */
    usr  = UART0_STATUS;
 8c4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
    data = UART0_DATA;
 8c8:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    
    /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */
#if defined(FE) && defined(DOR) && defined(UPE)
    lastRxError = usr & (_BV(FE)|_BV(DOR)|_BV(UPE) );
#elif defined(FE0) && defined(DOR0) && defined(UPE0)
    lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
 8cc:	8c 71       	andi	r24, 0x1C	; 28
#elif defined(FE) && defined(DOR)
    lastRxError = usr & (_BV(FE)|_BV(DOR) );
#endif

    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 8ce:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <UART_RxHead>
 8d2:	ef 5f       	subi	r30, 0xFF	; 255
 8d4:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART_RxTail ) {
 8d6:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <UART_RxTail>
 8da:	e9 17       	cp	r30, r25
 8dc:	39 f0       	breq	.+14     	; 0x8ec <__vector_20+0x3c>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
 8de:	e0 93 82 01 	sts	0x0182, r30	; 0x800182 <UART_RxHead>
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
 8e2:	f0 e0       	ldi	r31, 0x00	; 0
 8e4:	eb 57       	subi	r30, 0x7B	; 123
 8e6:	fe 4f       	sbci	r31, 0xFE	; 254
 8e8:	20 83       	st	Z, r18
 8ea:	01 c0       	rjmp	.+2      	; 0x8ee <__vector_20+0x3e>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
 8ec:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
 8ee:	90 91 80 01 	lds	r25, 0x0180	; 0x800180 <UART_LastRxError>
 8f2:	89 2b       	or	r24, r25
 8f4:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <UART_LastRxError>
}
 8f8:	ff 91       	pop	r31
 8fa:	ef 91       	pop	r30
 8fc:	9f 91       	pop	r25
 8fe:	8f 91       	pop	r24
 900:	2f 91       	pop	r18
 902:	0f 90       	pop	r0
 904:	0f be       	out	0x3f, r0	; 63
 906:	0f 90       	pop	r0
 908:	1f 90       	pop	r1
 90a:	18 95       	reti

0000090c <__vector_21>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
 90c:	1f 92       	push	r1
 90e:	0f 92       	push	r0
 910:	0f b6       	in	r0, 0x3f	; 63
 912:	0f 92       	push	r0
 914:	11 24       	eor	r1, r1
 916:	8f 93       	push	r24
 918:	9f 93       	push	r25
 91a:	ef 93       	push	r30
 91c:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
 91e:	90 91 84 01 	lds	r25, 0x0184	; 0x800184 <UART_TxHead>
 922:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <UART_TxTail>
 926:	98 17       	cp	r25, r24
 928:	69 f0       	breq	.+26     	; 0x944 <__vector_21+0x38>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 92a:	e0 91 83 01 	lds	r30, 0x0183	; 0x800183 <UART_TxTail>
 92e:	ef 5f       	subi	r30, 0xFF	; 255
 930:	ef 71       	andi	r30, 0x1F	; 31
        UART_TxTail = tmptail;
 932:	e0 93 83 01 	sts	0x0183, r30	; 0x800183 <UART_TxTail>
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 936:	f0 e0       	ldi	r31, 0x00	; 0
 938:	eb 55       	subi	r30, 0x5B	; 91
 93a:	fe 4f       	sbci	r31, 0xFE	; 254
 93c:	80 81       	ld	r24, Z
 93e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 942:	05 c0       	rjmp	.+10     	; 0x94e <__vector_21+0x42>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
 944:	e1 ec       	ldi	r30, 0xC1	; 193
 946:	f0 e0       	ldi	r31, 0x00	; 0
 948:	80 81       	ld	r24, Z
 94a:	8f 7d       	andi	r24, 0xDF	; 223
 94c:	80 83       	st	Z, r24
    }
}
 94e:	ff 91       	pop	r31
 950:	ef 91       	pop	r30
 952:	9f 91       	pop	r25
 954:	8f 91       	pop	r24
 956:	0f 90       	pop	r0
 958:	0f be       	out	0x3f, r0	; 63
 95a:	0f 90       	pop	r0
 95c:	1f 90       	pop	r1
 95e:	18 95       	reti

00000960 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
 960:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <UART_TxHead>
    UART_TxTail = 0;
 964:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <UART_TxTail>
    UART_RxHead = 0;
 968:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <UART_RxHead>
    UART_RxTail = 0;
 96c:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <UART_RxTail>
#endif
#endif
#endif

    /* Set baud rate */
    if ( baudrate & 0x8000 )
 970:	99 23       	and	r25, r25
 972:	1c f4       	brge	.+6      	; 0x97a <uart_init+0x1a>
    {
        #if UART0_BIT_U2X
        UART0_STATUS = (1<<UART0_BIT_U2X);  //Enable 2x speed 
 974:	22 e0       	ldi	r18, 0x02	; 2
 976:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
        #endif
    } 
    #if defined(UART0_UBRRH)
    UART0_UBRRH = (unsigned char)((baudrate>>8)&0x80) ;
 97a:	90 78       	andi	r25, 0x80	; 128
 97c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    #endif    
    UART0_UBRRL = (unsigned char) (baudrate&0x00FF);
 980:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
      
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(UART0_BIT_RXCIE)|(1<<UART0_BIT_RXEN)|(1<<UART0_BIT_TXEN);
 984:	88 e9       	ldi	r24, 0x98	; 152
 986:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef UART0_CONTROLC
    #ifdef UART0_BIT_URSEL
    UART0_CONTROLC = (1<<UART0_BIT_URSEL)|(1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
    #else
    UART0_CONTROLC = (1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 98a:	86 e0       	ldi	r24, 0x06	; 6
 98c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 990:	08 95       	ret

00000992 <uart_getc>:
    unsigned char tmptail;
    unsigned char data;
    unsigned char lastRxError;


    if ( UART_RxHead == UART_RxTail ) {
 992:	90 91 82 01 	lds	r25, 0x0182	; 0x800182 <UART_RxHead>
 996:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <UART_RxTail>
 99a:	98 17       	cp	r25, r24
 99c:	a9 f0       	breq	.+42     	; 0x9c8 <uart_getc+0x36>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 99e:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <UART_RxTail>
 9a2:	9f 5f       	subi	r25, 0xFF	; 255
 9a4:	9f 71       	andi	r25, 0x1F	; 31
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
 9a6:	e9 2f       	mov	r30, r25
 9a8:	f0 e0       	ldi	r31, 0x00	; 0
 9aa:	eb 57       	subi	r30, 0x7B	; 123
 9ac:	fe 4f       	sbci	r31, 0xFE	; 254
 9ae:	20 81       	ld	r18, Z
    lastRxError = UART_LastRxError;
 9b0:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <UART_LastRxError>
    
    /* store buffer index */
    UART_RxTail = tmptail; 
 9b4:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <UART_RxTail>
    
    UART_LastRxError = 0;
 9b8:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <UART_LastRxError>
    return (lastRxError << 8) + data;
 9bc:	90 e0       	ldi	r25, 0x00	; 0
 9be:	98 2f       	mov	r25, r24
 9c0:	88 27       	eor	r24, r24
 9c2:	82 0f       	add	r24, r18
 9c4:	91 1d       	adc	r25, r1
 9c6:	08 95       	ret
    unsigned char data;
    unsigned char lastRxError;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
 9c8:	80 e0       	ldi	r24, 0x00	; 0
 9ca:	91 e0       	ldi	r25, 0x01	; 1
    UART_RxTail = tmptail; 
    
    UART_LastRxError = 0;
    return (lastRxError << 8) + data;

}/* uart_getc */
 9cc:	08 95       	ret

000009ce <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 9ce:	20 91 84 01 	lds	r18, 0x0184	; 0x800184 <UART_TxHead>
 9d2:	2f 5f       	subi	r18, 0xFF	; 255
 9d4:	2f 71       	andi	r18, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
 9d6:	90 91 83 01 	lds	r25, 0x0183	; 0x800183 <UART_TxTail>
 9da:	29 17       	cp	r18, r25
 9dc:	e1 f3       	breq	.-8      	; 0x9d6 <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
 9de:	e2 2f       	mov	r30, r18
 9e0:	f0 e0       	ldi	r31, 0x00	; 0
 9e2:	eb 55       	subi	r30, 0x5B	; 91
 9e4:	fe 4f       	sbci	r31, 0xFE	; 254
 9e6:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
 9e8:	20 93 84 01 	sts	0x0184, r18	; 0x800184 <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
 9ec:	e1 ec       	ldi	r30, 0xC1	; 193
 9ee:	f0 e0       	ldi	r31, 0x00	; 0
 9f0:	80 81       	ld	r24, Z
 9f2:	80 62       	ori	r24, 0x20	; 32
 9f4:	80 83       	st	Z, r24
 9f6:	08 95       	ret

000009f8 <uart_puts>:
Purpose:  transmit string to UART
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
 9f8:	cf 93       	push	r28
 9fa:	df 93       	push	r29
 9fc:	ec 01       	movw	r28, r24
    while (*s) 
 9fe:	88 81       	ld	r24, Y
 a00:	88 23       	and	r24, r24
 a02:	31 f0       	breq	.+12     	; 0xa10 <uart_puts+0x18>
 a04:	21 96       	adiw	r28, 0x01	; 1
      uart_putc(*s++);
 a06:	0e 94 e7 04 	call	0x9ce	; 0x9ce <uart_putc>
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    while (*s) 
 a0a:	89 91       	ld	r24, Y+
 a0c:	81 11       	cpse	r24, r1
 a0e:	fb cf       	rjmp	.-10     	; 0xa06 <uart_puts+0xe>
      uart_putc(*s++);

}/* uart_puts */
 a10:	df 91       	pop	r29
 a12:	cf 91       	pop	r28
 a14:	08 95       	ret

00000a16 <uart_puts_p>:
Purpose:  transmit string from program memory to UART
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void uart_puts_p(const char *progmem_s )
{
 a16:	cf 93       	push	r28
 a18:	df 93       	push	r29
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
 a1a:	ec 01       	movw	r28, r24
 a1c:	21 96       	adiw	r28, 0x01	; 1
 a1e:	fc 01       	movw	r30, r24
 a20:	84 91       	lpm	r24, Z
 a22:	88 23       	and	r24, r24
 a24:	39 f0       	breq	.+14     	; 0xa34 <uart_puts_p+0x1e>
      uart_putc(c);
 a26:	0e 94 e7 04 	call	0x9ce	; 0x9ce <uart_putc>
**************************************************************************/
void uart_puts_p(const char *progmem_s )
{
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
 a2a:	fe 01       	movw	r30, r28
 a2c:	84 91       	lpm	r24, Z
 a2e:	21 96       	adiw	r28, 0x01	; 1
 a30:	81 11       	cpse	r24, r1
 a32:	f9 cf       	rjmp	.-14     	; 0xa26 <uart_puts_p+0x10>
      uart_putc(c);

}/* uart_puts_p */
 a34:	df 91       	pop	r29
 a36:	cf 91       	pop	r28
 a38:	08 95       	ret

00000a3a <__subsf3>:
 a3a:	50 58       	subi	r21, 0x80	; 128

00000a3c <__addsf3>:
 a3c:	bb 27       	eor	r27, r27
 a3e:	aa 27       	eor	r26, r26
 a40:	0e 94 35 05 	call	0xa6a	; 0xa6a <__addsf3x>
 a44:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <__fp_round>
 a48:	0e 94 78 06 	call	0xcf0	; 0xcf0 <__fp_pscA>
 a4c:	38 f0       	brcs	.+14     	; 0xa5c <__addsf3+0x20>
 a4e:	0e 94 7f 06 	call	0xcfe	; 0xcfe <__fp_pscB>
 a52:	20 f0       	brcs	.+8      	; 0xa5c <__addsf3+0x20>
 a54:	39 f4       	brne	.+14     	; 0xa64 <__addsf3+0x28>
 a56:	9f 3f       	cpi	r25, 0xFF	; 255
 a58:	19 f4       	brne	.+6      	; 0xa60 <__addsf3+0x24>
 a5a:	26 f4       	brtc	.+8      	; 0xa64 <__addsf3+0x28>
 a5c:	0c 94 75 06 	jmp	0xcea	; 0xcea <__fp_nan>
 a60:	0e f4       	brtc	.+2      	; 0xa64 <__addsf3+0x28>
 a62:	e0 95       	com	r30
 a64:	e7 fb       	bst	r30, 7
 a66:	0c 94 6f 06 	jmp	0xcde	; 0xcde <__fp_inf>

00000a6a <__addsf3x>:
 a6a:	e9 2f       	mov	r30, r25
 a6c:	0e 94 97 06 	call	0xd2e	; 0xd2e <__fp_split3>
 a70:	58 f3       	brcs	.-42     	; 0xa48 <__addsf3+0xc>
 a72:	ba 17       	cp	r27, r26
 a74:	62 07       	cpc	r22, r18
 a76:	73 07       	cpc	r23, r19
 a78:	84 07       	cpc	r24, r20
 a7a:	95 07       	cpc	r25, r21
 a7c:	20 f0       	brcs	.+8      	; 0xa86 <__addsf3x+0x1c>
 a7e:	79 f4       	brne	.+30     	; 0xa9e <__addsf3x+0x34>
 a80:	a6 f5       	brtc	.+104    	; 0xaea <__addsf3x+0x80>
 a82:	0c 94 b9 06 	jmp	0xd72	; 0xd72 <__fp_zero>
 a86:	0e f4       	brtc	.+2      	; 0xa8a <__addsf3x+0x20>
 a88:	e0 95       	com	r30
 a8a:	0b 2e       	mov	r0, r27
 a8c:	ba 2f       	mov	r27, r26
 a8e:	a0 2d       	mov	r26, r0
 a90:	0b 01       	movw	r0, r22
 a92:	b9 01       	movw	r22, r18
 a94:	90 01       	movw	r18, r0
 a96:	0c 01       	movw	r0, r24
 a98:	ca 01       	movw	r24, r20
 a9a:	a0 01       	movw	r20, r0
 a9c:	11 24       	eor	r1, r1
 a9e:	ff 27       	eor	r31, r31
 aa0:	59 1b       	sub	r21, r25
 aa2:	99 f0       	breq	.+38     	; 0xaca <__addsf3x+0x60>
 aa4:	59 3f       	cpi	r21, 0xF9	; 249
 aa6:	50 f4       	brcc	.+20     	; 0xabc <__addsf3x+0x52>
 aa8:	50 3e       	cpi	r21, 0xE0	; 224
 aaa:	68 f1       	brcs	.+90     	; 0xb06 <__addsf3x+0x9c>
 aac:	1a 16       	cp	r1, r26
 aae:	f0 40       	sbci	r31, 0x00	; 0
 ab0:	a2 2f       	mov	r26, r18
 ab2:	23 2f       	mov	r18, r19
 ab4:	34 2f       	mov	r19, r20
 ab6:	44 27       	eor	r20, r20
 ab8:	58 5f       	subi	r21, 0xF8	; 248
 aba:	f3 cf       	rjmp	.-26     	; 0xaa2 <__addsf3x+0x38>
 abc:	46 95       	lsr	r20
 abe:	37 95       	ror	r19
 ac0:	27 95       	ror	r18
 ac2:	a7 95       	ror	r26
 ac4:	f0 40       	sbci	r31, 0x00	; 0
 ac6:	53 95       	inc	r21
 ac8:	c9 f7       	brne	.-14     	; 0xabc <__addsf3x+0x52>
 aca:	7e f4       	brtc	.+30     	; 0xaea <__addsf3x+0x80>
 acc:	1f 16       	cp	r1, r31
 ace:	ba 0b       	sbc	r27, r26
 ad0:	62 0b       	sbc	r22, r18
 ad2:	73 0b       	sbc	r23, r19
 ad4:	84 0b       	sbc	r24, r20
 ad6:	ba f0       	brmi	.+46     	; 0xb06 <__addsf3x+0x9c>
 ad8:	91 50       	subi	r25, 0x01	; 1
 ada:	a1 f0       	breq	.+40     	; 0xb04 <__addsf3x+0x9a>
 adc:	ff 0f       	add	r31, r31
 ade:	bb 1f       	adc	r27, r27
 ae0:	66 1f       	adc	r22, r22
 ae2:	77 1f       	adc	r23, r23
 ae4:	88 1f       	adc	r24, r24
 ae6:	c2 f7       	brpl	.-16     	; 0xad8 <__addsf3x+0x6e>
 ae8:	0e c0       	rjmp	.+28     	; 0xb06 <__addsf3x+0x9c>
 aea:	ba 0f       	add	r27, r26
 aec:	62 1f       	adc	r22, r18
 aee:	73 1f       	adc	r23, r19
 af0:	84 1f       	adc	r24, r20
 af2:	48 f4       	brcc	.+18     	; 0xb06 <__addsf3x+0x9c>
 af4:	87 95       	ror	r24
 af6:	77 95       	ror	r23
 af8:	67 95       	ror	r22
 afa:	b7 95       	ror	r27
 afc:	f7 95       	ror	r31
 afe:	9e 3f       	cpi	r25, 0xFE	; 254
 b00:	08 f0       	brcs	.+2      	; 0xb04 <__addsf3x+0x9a>
 b02:	b0 cf       	rjmp	.-160    	; 0xa64 <__addsf3+0x28>
 b04:	93 95       	inc	r25
 b06:	88 0f       	add	r24, r24
 b08:	08 f0       	brcs	.+2      	; 0xb0c <__addsf3x+0xa2>
 b0a:	99 27       	eor	r25, r25
 b0c:	ee 0f       	add	r30, r30
 b0e:	97 95       	ror	r25
 b10:	87 95       	ror	r24
 b12:	08 95       	ret

00000b14 <__divsf3>:
 b14:	0e 94 9e 05 	call	0xb3c	; 0xb3c <__divsf3x>
 b18:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <__fp_round>
 b1c:	0e 94 7f 06 	call	0xcfe	; 0xcfe <__fp_pscB>
 b20:	58 f0       	brcs	.+22     	; 0xb38 <__divsf3+0x24>
 b22:	0e 94 78 06 	call	0xcf0	; 0xcf0 <__fp_pscA>
 b26:	40 f0       	brcs	.+16     	; 0xb38 <__divsf3+0x24>
 b28:	29 f4       	brne	.+10     	; 0xb34 <__divsf3+0x20>
 b2a:	5f 3f       	cpi	r21, 0xFF	; 255
 b2c:	29 f0       	breq	.+10     	; 0xb38 <__divsf3+0x24>
 b2e:	0c 94 6f 06 	jmp	0xcde	; 0xcde <__fp_inf>
 b32:	51 11       	cpse	r21, r1
 b34:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_szero>
 b38:	0c 94 75 06 	jmp	0xcea	; 0xcea <__fp_nan>

00000b3c <__divsf3x>:
 b3c:	0e 94 97 06 	call	0xd2e	; 0xd2e <__fp_split3>
 b40:	68 f3       	brcs	.-38     	; 0xb1c <__divsf3+0x8>

00000b42 <__divsf3_pse>:
 b42:	99 23       	and	r25, r25
 b44:	b1 f3       	breq	.-20     	; 0xb32 <__divsf3+0x1e>
 b46:	55 23       	and	r21, r21
 b48:	91 f3       	breq	.-28     	; 0xb2e <__divsf3+0x1a>
 b4a:	95 1b       	sub	r25, r21
 b4c:	55 0b       	sbc	r21, r21
 b4e:	bb 27       	eor	r27, r27
 b50:	aa 27       	eor	r26, r26
 b52:	62 17       	cp	r22, r18
 b54:	73 07       	cpc	r23, r19
 b56:	84 07       	cpc	r24, r20
 b58:	38 f0       	brcs	.+14     	; 0xb68 <__divsf3_pse+0x26>
 b5a:	9f 5f       	subi	r25, 0xFF	; 255
 b5c:	5f 4f       	sbci	r21, 0xFF	; 255
 b5e:	22 0f       	add	r18, r18
 b60:	33 1f       	adc	r19, r19
 b62:	44 1f       	adc	r20, r20
 b64:	aa 1f       	adc	r26, r26
 b66:	a9 f3       	breq	.-22     	; 0xb52 <__divsf3_pse+0x10>
 b68:	35 d0       	rcall	.+106    	; 0xbd4 <__divsf3_pse+0x92>
 b6a:	0e 2e       	mov	r0, r30
 b6c:	3a f0       	brmi	.+14     	; 0xb7c <__divsf3_pse+0x3a>
 b6e:	e0 e8       	ldi	r30, 0x80	; 128
 b70:	32 d0       	rcall	.+100    	; 0xbd6 <__divsf3_pse+0x94>
 b72:	91 50       	subi	r25, 0x01	; 1
 b74:	50 40       	sbci	r21, 0x00	; 0
 b76:	e6 95       	lsr	r30
 b78:	00 1c       	adc	r0, r0
 b7a:	ca f7       	brpl	.-14     	; 0xb6e <__divsf3_pse+0x2c>
 b7c:	2b d0       	rcall	.+86     	; 0xbd4 <__divsf3_pse+0x92>
 b7e:	fe 2f       	mov	r31, r30
 b80:	29 d0       	rcall	.+82     	; 0xbd4 <__divsf3_pse+0x92>
 b82:	66 0f       	add	r22, r22
 b84:	77 1f       	adc	r23, r23
 b86:	88 1f       	adc	r24, r24
 b88:	bb 1f       	adc	r27, r27
 b8a:	26 17       	cp	r18, r22
 b8c:	37 07       	cpc	r19, r23
 b8e:	48 07       	cpc	r20, r24
 b90:	ab 07       	cpc	r26, r27
 b92:	b0 e8       	ldi	r27, 0x80	; 128
 b94:	09 f0       	breq	.+2      	; 0xb98 <__divsf3_pse+0x56>
 b96:	bb 0b       	sbc	r27, r27
 b98:	80 2d       	mov	r24, r0
 b9a:	bf 01       	movw	r22, r30
 b9c:	ff 27       	eor	r31, r31
 b9e:	93 58       	subi	r25, 0x83	; 131
 ba0:	5f 4f       	sbci	r21, 0xFF	; 255
 ba2:	3a f0       	brmi	.+14     	; 0xbb2 <__divsf3_pse+0x70>
 ba4:	9e 3f       	cpi	r25, 0xFE	; 254
 ba6:	51 05       	cpc	r21, r1
 ba8:	78 f0       	brcs	.+30     	; 0xbc8 <__divsf3_pse+0x86>
 baa:	0c 94 6f 06 	jmp	0xcde	; 0xcde <__fp_inf>
 bae:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_szero>
 bb2:	5f 3f       	cpi	r21, 0xFF	; 255
 bb4:	e4 f3       	brlt	.-8      	; 0xbae <__divsf3_pse+0x6c>
 bb6:	98 3e       	cpi	r25, 0xE8	; 232
 bb8:	d4 f3       	brlt	.-12     	; 0xbae <__divsf3_pse+0x6c>
 bba:	86 95       	lsr	r24
 bbc:	77 95       	ror	r23
 bbe:	67 95       	ror	r22
 bc0:	b7 95       	ror	r27
 bc2:	f7 95       	ror	r31
 bc4:	9f 5f       	subi	r25, 0xFF	; 255
 bc6:	c9 f7       	brne	.-14     	; 0xbba <__divsf3_pse+0x78>
 bc8:	88 0f       	add	r24, r24
 bca:	91 1d       	adc	r25, r1
 bcc:	96 95       	lsr	r25
 bce:	87 95       	ror	r24
 bd0:	97 f9       	bld	r25, 7
 bd2:	08 95       	ret
 bd4:	e1 e0       	ldi	r30, 0x01	; 1
 bd6:	66 0f       	add	r22, r22
 bd8:	77 1f       	adc	r23, r23
 bda:	88 1f       	adc	r24, r24
 bdc:	bb 1f       	adc	r27, r27
 bde:	62 17       	cp	r22, r18
 be0:	73 07       	cpc	r23, r19
 be2:	84 07       	cpc	r24, r20
 be4:	ba 07       	cpc	r27, r26
 be6:	20 f0       	brcs	.+8      	; 0xbf0 <__divsf3_pse+0xae>
 be8:	62 1b       	sub	r22, r18
 bea:	73 0b       	sbc	r23, r19
 bec:	84 0b       	sbc	r24, r20
 bee:	ba 0b       	sbc	r27, r26
 bf0:	ee 1f       	adc	r30, r30
 bf2:	88 f7       	brcc	.-30     	; 0xbd6 <__divsf3_pse+0x94>
 bf4:	e0 95       	com	r30
 bf6:	08 95       	ret

00000bf8 <__fixsfsi>:
 bf8:	0e 94 03 06 	call	0xc06	; 0xc06 <__fixunssfsi>
 bfc:	68 94       	set
 bfe:	b1 11       	cpse	r27, r1
 c00:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_szero>
 c04:	08 95       	ret

00000c06 <__fixunssfsi>:
 c06:	0e 94 9f 06 	call	0xd3e	; 0xd3e <__fp_splitA>
 c0a:	88 f0       	brcs	.+34     	; 0xc2e <__fixunssfsi+0x28>
 c0c:	9f 57       	subi	r25, 0x7F	; 127
 c0e:	98 f0       	brcs	.+38     	; 0xc36 <__fixunssfsi+0x30>
 c10:	b9 2f       	mov	r27, r25
 c12:	99 27       	eor	r25, r25
 c14:	b7 51       	subi	r27, 0x17	; 23
 c16:	b0 f0       	brcs	.+44     	; 0xc44 <__fixunssfsi+0x3e>
 c18:	e1 f0       	breq	.+56     	; 0xc52 <__fixunssfsi+0x4c>
 c1a:	66 0f       	add	r22, r22
 c1c:	77 1f       	adc	r23, r23
 c1e:	88 1f       	adc	r24, r24
 c20:	99 1f       	adc	r25, r25
 c22:	1a f0       	brmi	.+6      	; 0xc2a <__fixunssfsi+0x24>
 c24:	ba 95       	dec	r27
 c26:	c9 f7       	brne	.-14     	; 0xc1a <__fixunssfsi+0x14>
 c28:	14 c0       	rjmp	.+40     	; 0xc52 <__fixunssfsi+0x4c>
 c2a:	b1 30       	cpi	r27, 0x01	; 1
 c2c:	91 f0       	breq	.+36     	; 0xc52 <__fixunssfsi+0x4c>
 c2e:	0e 94 b9 06 	call	0xd72	; 0xd72 <__fp_zero>
 c32:	b1 e0       	ldi	r27, 0x01	; 1
 c34:	08 95       	ret
 c36:	0c 94 b9 06 	jmp	0xd72	; 0xd72 <__fp_zero>
 c3a:	67 2f       	mov	r22, r23
 c3c:	78 2f       	mov	r23, r24
 c3e:	88 27       	eor	r24, r24
 c40:	b8 5f       	subi	r27, 0xF8	; 248
 c42:	39 f0       	breq	.+14     	; 0xc52 <__fixunssfsi+0x4c>
 c44:	b9 3f       	cpi	r27, 0xF9	; 249
 c46:	cc f3       	brlt	.-14     	; 0xc3a <__fixunssfsi+0x34>
 c48:	86 95       	lsr	r24
 c4a:	77 95       	ror	r23
 c4c:	67 95       	ror	r22
 c4e:	b3 95       	inc	r27
 c50:	d9 f7       	brne	.-10     	; 0xc48 <__fixunssfsi+0x42>
 c52:	3e f4       	brtc	.+14     	; 0xc62 <__fixunssfsi+0x5c>
 c54:	90 95       	com	r25
 c56:	80 95       	com	r24
 c58:	70 95       	com	r23
 c5a:	61 95       	neg	r22
 c5c:	7f 4f       	sbci	r23, 0xFF	; 255
 c5e:	8f 4f       	sbci	r24, 0xFF	; 255
 c60:	9f 4f       	sbci	r25, 0xFF	; 255
 c62:	08 95       	ret

00000c64 <__floatunsisf>:
 c64:	e8 94       	clt
 c66:	09 c0       	rjmp	.+18     	; 0xc7a <__floatsisf+0x12>

00000c68 <__floatsisf>:
 c68:	97 fb       	bst	r25, 7
 c6a:	3e f4       	brtc	.+14     	; 0xc7a <__floatsisf+0x12>
 c6c:	90 95       	com	r25
 c6e:	80 95       	com	r24
 c70:	70 95       	com	r23
 c72:	61 95       	neg	r22
 c74:	7f 4f       	sbci	r23, 0xFF	; 255
 c76:	8f 4f       	sbci	r24, 0xFF	; 255
 c78:	9f 4f       	sbci	r25, 0xFF	; 255
 c7a:	99 23       	and	r25, r25
 c7c:	a9 f0       	breq	.+42     	; 0xca8 <__floatsisf+0x40>
 c7e:	f9 2f       	mov	r31, r25
 c80:	96 e9       	ldi	r25, 0x96	; 150
 c82:	bb 27       	eor	r27, r27
 c84:	93 95       	inc	r25
 c86:	f6 95       	lsr	r31
 c88:	87 95       	ror	r24
 c8a:	77 95       	ror	r23
 c8c:	67 95       	ror	r22
 c8e:	b7 95       	ror	r27
 c90:	f1 11       	cpse	r31, r1
 c92:	f8 cf       	rjmp	.-16     	; 0xc84 <__floatsisf+0x1c>
 c94:	fa f4       	brpl	.+62     	; 0xcd4 <__floatsisf+0x6c>
 c96:	bb 0f       	add	r27, r27
 c98:	11 f4       	brne	.+4      	; 0xc9e <__floatsisf+0x36>
 c9a:	60 ff       	sbrs	r22, 0
 c9c:	1b c0       	rjmp	.+54     	; 0xcd4 <__floatsisf+0x6c>
 c9e:	6f 5f       	subi	r22, 0xFF	; 255
 ca0:	7f 4f       	sbci	r23, 0xFF	; 255
 ca2:	8f 4f       	sbci	r24, 0xFF	; 255
 ca4:	9f 4f       	sbci	r25, 0xFF	; 255
 ca6:	16 c0       	rjmp	.+44     	; 0xcd4 <__floatsisf+0x6c>
 ca8:	88 23       	and	r24, r24
 caa:	11 f0       	breq	.+4      	; 0xcb0 <__floatsisf+0x48>
 cac:	96 e9       	ldi	r25, 0x96	; 150
 cae:	11 c0       	rjmp	.+34     	; 0xcd2 <__floatsisf+0x6a>
 cb0:	77 23       	and	r23, r23
 cb2:	21 f0       	breq	.+8      	; 0xcbc <__floatsisf+0x54>
 cb4:	9e e8       	ldi	r25, 0x8E	; 142
 cb6:	87 2f       	mov	r24, r23
 cb8:	76 2f       	mov	r23, r22
 cba:	05 c0       	rjmp	.+10     	; 0xcc6 <__floatsisf+0x5e>
 cbc:	66 23       	and	r22, r22
 cbe:	71 f0       	breq	.+28     	; 0xcdc <__floatsisf+0x74>
 cc0:	96 e8       	ldi	r25, 0x86	; 134
 cc2:	86 2f       	mov	r24, r22
 cc4:	70 e0       	ldi	r23, 0x00	; 0
 cc6:	60 e0       	ldi	r22, 0x00	; 0
 cc8:	2a f0       	brmi	.+10     	; 0xcd4 <__floatsisf+0x6c>
 cca:	9a 95       	dec	r25
 ccc:	66 0f       	add	r22, r22
 cce:	77 1f       	adc	r23, r23
 cd0:	88 1f       	adc	r24, r24
 cd2:	da f7       	brpl	.-10     	; 0xcca <__floatsisf+0x62>
 cd4:	88 0f       	add	r24, r24
 cd6:	96 95       	lsr	r25
 cd8:	87 95       	ror	r24
 cda:	97 f9       	bld	r25, 7
 cdc:	08 95       	ret

00000cde <__fp_inf>:
 cde:	97 f9       	bld	r25, 7
 ce0:	9f 67       	ori	r25, 0x7F	; 127
 ce2:	80 e8       	ldi	r24, 0x80	; 128
 ce4:	70 e0       	ldi	r23, 0x00	; 0
 ce6:	60 e0       	ldi	r22, 0x00	; 0
 ce8:	08 95       	ret

00000cea <__fp_nan>:
 cea:	9f ef       	ldi	r25, 0xFF	; 255
 cec:	80 ec       	ldi	r24, 0xC0	; 192
 cee:	08 95       	ret

00000cf0 <__fp_pscA>:
 cf0:	00 24       	eor	r0, r0
 cf2:	0a 94       	dec	r0
 cf4:	16 16       	cp	r1, r22
 cf6:	17 06       	cpc	r1, r23
 cf8:	18 06       	cpc	r1, r24
 cfa:	09 06       	cpc	r0, r25
 cfc:	08 95       	ret

00000cfe <__fp_pscB>:
 cfe:	00 24       	eor	r0, r0
 d00:	0a 94       	dec	r0
 d02:	12 16       	cp	r1, r18
 d04:	13 06       	cpc	r1, r19
 d06:	14 06       	cpc	r1, r20
 d08:	05 06       	cpc	r0, r21
 d0a:	08 95       	ret

00000d0c <__fp_round>:
 d0c:	09 2e       	mov	r0, r25
 d0e:	03 94       	inc	r0
 d10:	00 0c       	add	r0, r0
 d12:	11 f4       	brne	.+4      	; 0xd18 <__fp_round+0xc>
 d14:	88 23       	and	r24, r24
 d16:	52 f0       	brmi	.+20     	; 0xd2c <__fp_round+0x20>
 d18:	bb 0f       	add	r27, r27
 d1a:	40 f4       	brcc	.+16     	; 0xd2c <__fp_round+0x20>
 d1c:	bf 2b       	or	r27, r31
 d1e:	11 f4       	brne	.+4      	; 0xd24 <__fp_round+0x18>
 d20:	60 ff       	sbrs	r22, 0
 d22:	04 c0       	rjmp	.+8      	; 0xd2c <__fp_round+0x20>
 d24:	6f 5f       	subi	r22, 0xFF	; 255
 d26:	7f 4f       	sbci	r23, 0xFF	; 255
 d28:	8f 4f       	sbci	r24, 0xFF	; 255
 d2a:	9f 4f       	sbci	r25, 0xFF	; 255
 d2c:	08 95       	ret

00000d2e <__fp_split3>:
 d2e:	57 fd       	sbrc	r21, 7
 d30:	90 58       	subi	r25, 0x80	; 128
 d32:	44 0f       	add	r20, r20
 d34:	55 1f       	adc	r21, r21
 d36:	59 f0       	breq	.+22     	; 0xd4e <__fp_splitA+0x10>
 d38:	5f 3f       	cpi	r21, 0xFF	; 255
 d3a:	71 f0       	breq	.+28     	; 0xd58 <__fp_splitA+0x1a>
 d3c:	47 95       	ror	r20

00000d3e <__fp_splitA>:
 d3e:	88 0f       	add	r24, r24
 d40:	97 fb       	bst	r25, 7
 d42:	99 1f       	adc	r25, r25
 d44:	61 f0       	breq	.+24     	; 0xd5e <__fp_splitA+0x20>
 d46:	9f 3f       	cpi	r25, 0xFF	; 255
 d48:	79 f0       	breq	.+30     	; 0xd68 <__fp_splitA+0x2a>
 d4a:	87 95       	ror	r24
 d4c:	08 95       	ret
 d4e:	12 16       	cp	r1, r18
 d50:	13 06       	cpc	r1, r19
 d52:	14 06       	cpc	r1, r20
 d54:	55 1f       	adc	r21, r21
 d56:	f2 cf       	rjmp	.-28     	; 0xd3c <__fp_split3+0xe>
 d58:	46 95       	lsr	r20
 d5a:	f1 df       	rcall	.-30     	; 0xd3e <__fp_splitA>
 d5c:	08 c0       	rjmp	.+16     	; 0xd6e <__fp_splitA+0x30>
 d5e:	16 16       	cp	r1, r22
 d60:	17 06       	cpc	r1, r23
 d62:	18 06       	cpc	r1, r24
 d64:	99 1f       	adc	r25, r25
 d66:	f1 cf       	rjmp	.-30     	; 0xd4a <__fp_splitA+0xc>
 d68:	86 95       	lsr	r24
 d6a:	71 05       	cpc	r23, r1
 d6c:	61 05       	cpc	r22, r1
 d6e:	08 94       	sec
 d70:	08 95       	ret

00000d72 <__fp_zero>:
 d72:	e8 94       	clt

00000d74 <__fp_szero>:
 d74:	bb 27       	eor	r27, r27
 d76:	66 27       	eor	r22, r22
 d78:	77 27       	eor	r23, r23
 d7a:	cb 01       	movw	r24, r22
 d7c:	97 f9       	bld	r25, 7
 d7e:	08 95       	ret

00000d80 <__gesf2>:
 d80:	0e 94 32 07 	call	0xe64	; 0xe64 <__fp_cmp>
 d84:	08 f4       	brcc	.+2      	; 0xd88 <__gesf2+0x8>
 d86:	8f ef       	ldi	r24, 0xFF	; 255
 d88:	08 95       	ret

00000d8a <__mulsf3>:
 d8a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <__mulsf3x>
 d8e:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <__fp_round>
 d92:	0e 94 78 06 	call	0xcf0	; 0xcf0 <__fp_pscA>
 d96:	38 f0       	brcs	.+14     	; 0xda6 <__mulsf3+0x1c>
 d98:	0e 94 7f 06 	call	0xcfe	; 0xcfe <__fp_pscB>
 d9c:	20 f0       	brcs	.+8      	; 0xda6 <__mulsf3+0x1c>
 d9e:	95 23       	and	r25, r21
 da0:	11 f0       	breq	.+4      	; 0xda6 <__mulsf3+0x1c>
 da2:	0c 94 6f 06 	jmp	0xcde	; 0xcde <__fp_inf>
 da6:	0c 94 75 06 	jmp	0xcea	; 0xcea <__fp_nan>
 daa:	11 24       	eor	r1, r1
 dac:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_szero>

00000db0 <__mulsf3x>:
 db0:	0e 94 97 06 	call	0xd2e	; 0xd2e <__fp_split3>
 db4:	70 f3       	brcs	.-36     	; 0xd92 <__mulsf3+0x8>

00000db6 <__mulsf3_pse>:
 db6:	95 9f       	mul	r25, r21
 db8:	c1 f3       	breq	.-16     	; 0xdaa <__mulsf3+0x20>
 dba:	95 0f       	add	r25, r21
 dbc:	50 e0       	ldi	r21, 0x00	; 0
 dbe:	55 1f       	adc	r21, r21
 dc0:	62 9f       	mul	r22, r18
 dc2:	f0 01       	movw	r30, r0
 dc4:	72 9f       	mul	r23, r18
 dc6:	bb 27       	eor	r27, r27
 dc8:	f0 0d       	add	r31, r0
 dca:	b1 1d       	adc	r27, r1
 dcc:	63 9f       	mul	r22, r19
 dce:	aa 27       	eor	r26, r26
 dd0:	f0 0d       	add	r31, r0
 dd2:	b1 1d       	adc	r27, r1
 dd4:	aa 1f       	adc	r26, r26
 dd6:	64 9f       	mul	r22, r20
 dd8:	66 27       	eor	r22, r22
 dda:	b0 0d       	add	r27, r0
 ddc:	a1 1d       	adc	r26, r1
 dde:	66 1f       	adc	r22, r22
 de0:	82 9f       	mul	r24, r18
 de2:	22 27       	eor	r18, r18
 de4:	b0 0d       	add	r27, r0
 de6:	a1 1d       	adc	r26, r1
 de8:	62 1f       	adc	r22, r18
 dea:	73 9f       	mul	r23, r19
 dec:	b0 0d       	add	r27, r0
 dee:	a1 1d       	adc	r26, r1
 df0:	62 1f       	adc	r22, r18
 df2:	83 9f       	mul	r24, r19
 df4:	a0 0d       	add	r26, r0
 df6:	61 1d       	adc	r22, r1
 df8:	22 1f       	adc	r18, r18
 dfa:	74 9f       	mul	r23, r20
 dfc:	33 27       	eor	r19, r19
 dfe:	a0 0d       	add	r26, r0
 e00:	61 1d       	adc	r22, r1
 e02:	23 1f       	adc	r18, r19
 e04:	84 9f       	mul	r24, r20
 e06:	60 0d       	add	r22, r0
 e08:	21 1d       	adc	r18, r1
 e0a:	82 2f       	mov	r24, r18
 e0c:	76 2f       	mov	r23, r22
 e0e:	6a 2f       	mov	r22, r26
 e10:	11 24       	eor	r1, r1
 e12:	9f 57       	subi	r25, 0x7F	; 127
 e14:	50 40       	sbci	r21, 0x00	; 0
 e16:	9a f0       	brmi	.+38     	; 0xe3e <__mulsf3_pse+0x88>
 e18:	f1 f0       	breq	.+60     	; 0xe56 <__mulsf3_pse+0xa0>
 e1a:	88 23       	and	r24, r24
 e1c:	4a f0       	brmi	.+18     	; 0xe30 <__mulsf3_pse+0x7a>
 e1e:	ee 0f       	add	r30, r30
 e20:	ff 1f       	adc	r31, r31
 e22:	bb 1f       	adc	r27, r27
 e24:	66 1f       	adc	r22, r22
 e26:	77 1f       	adc	r23, r23
 e28:	88 1f       	adc	r24, r24
 e2a:	91 50       	subi	r25, 0x01	; 1
 e2c:	50 40       	sbci	r21, 0x00	; 0
 e2e:	a9 f7       	brne	.-22     	; 0xe1a <__mulsf3_pse+0x64>
 e30:	9e 3f       	cpi	r25, 0xFE	; 254
 e32:	51 05       	cpc	r21, r1
 e34:	80 f0       	brcs	.+32     	; 0xe56 <__mulsf3_pse+0xa0>
 e36:	0c 94 6f 06 	jmp	0xcde	; 0xcde <__fp_inf>
 e3a:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_szero>
 e3e:	5f 3f       	cpi	r21, 0xFF	; 255
 e40:	e4 f3       	brlt	.-8      	; 0xe3a <__mulsf3_pse+0x84>
 e42:	98 3e       	cpi	r25, 0xE8	; 232
 e44:	d4 f3       	brlt	.-12     	; 0xe3a <__mulsf3_pse+0x84>
 e46:	86 95       	lsr	r24
 e48:	77 95       	ror	r23
 e4a:	67 95       	ror	r22
 e4c:	b7 95       	ror	r27
 e4e:	f7 95       	ror	r31
 e50:	e7 95       	ror	r30
 e52:	9f 5f       	subi	r25, 0xFF	; 255
 e54:	c1 f7       	brne	.-16     	; 0xe46 <__mulsf3_pse+0x90>
 e56:	fe 2b       	or	r31, r30
 e58:	88 0f       	add	r24, r24
 e5a:	91 1d       	adc	r25, r1
 e5c:	96 95       	lsr	r25
 e5e:	87 95       	ror	r24
 e60:	97 f9       	bld	r25, 7
 e62:	08 95       	ret

00000e64 <__fp_cmp>:
 e64:	99 0f       	add	r25, r25
 e66:	00 08       	sbc	r0, r0
 e68:	55 0f       	add	r21, r21
 e6a:	aa 0b       	sbc	r26, r26
 e6c:	e0 e8       	ldi	r30, 0x80	; 128
 e6e:	fe ef       	ldi	r31, 0xFE	; 254
 e70:	16 16       	cp	r1, r22
 e72:	17 06       	cpc	r1, r23
 e74:	e8 07       	cpc	r30, r24
 e76:	f9 07       	cpc	r31, r25
 e78:	c0 f0       	brcs	.+48     	; 0xeaa <__fp_cmp+0x46>
 e7a:	12 16       	cp	r1, r18
 e7c:	13 06       	cpc	r1, r19
 e7e:	e4 07       	cpc	r30, r20
 e80:	f5 07       	cpc	r31, r21
 e82:	98 f0       	brcs	.+38     	; 0xeaa <__fp_cmp+0x46>
 e84:	62 1b       	sub	r22, r18
 e86:	73 0b       	sbc	r23, r19
 e88:	84 0b       	sbc	r24, r20
 e8a:	95 0b       	sbc	r25, r21
 e8c:	39 f4       	brne	.+14     	; 0xe9c <__fp_cmp+0x38>
 e8e:	0a 26       	eor	r0, r26
 e90:	61 f0       	breq	.+24     	; 0xeaa <__fp_cmp+0x46>
 e92:	23 2b       	or	r18, r19
 e94:	24 2b       	or	r18, r20
 e96:	25 2b       	or	r18, r21
 e98:	21 f4       	brne	.+8      	; 0xea2 <__fp_cmp+0x3e>
 e9a:	08 95       	ret
 e9c:	0a 26       	eor	r0, r26
 e9e:	09 f4       	brne	.+2      	; 0xea2 <__fp_cmp+0x3e>
 ea0:	a1 40       	sbci	r26, 0x01	; 1
 ea2:	a6 95       	lsr	r26
 ea4:	8f ef       	ldi	r24, 0xFF	; 255
 ea6:	81 1d       	adc	r24, r1
 ea8:	81 1d       	adc	r24, r1
 eaa:	08 95       	ret

00000eac <__itoa_ncheck>:
 eac:	bb 27       	eor	r27, r27
 eae:	4a 30       	cpi	r20, 0x0A	; 10
 eb0:	31 f4       	brne	.+12     	; 0xebe <__itoa_ncheck+0x12>
 eb2:	99 23       	and	r25, r25
 eb4:	22 f4       	brpl	.+8      	; 0xebe <__itoa_ncheck+0x12>
 eb6:	bd e2       	ldi	r27, 0x2D	; 45
 eb8:	90 95       	com	r25
 eba:	81 95       	neg	r24
 ebc:	9f 4f       	sbci	r25, 0xFF	; 255
 ebe:	0c 94 62 07 	jmp	0xec4	; 0xec4 <__utoa_common>

00000ec2 <__utoa_ncheck>:
 ec2:	bb 27       	eor	r27, r27

00000ec4 <__utoa_common>:
 ec4:	fb 01       	movw	r30, r22
 ec6:	55 27       	eor	r21, r21
 ec8:	aa 27       	eor	r26, r26
 eca:	88 0f       	add	r24, r24
 ecc:	99 1f       	adc	r25, r25
 ece:	aa 1f       	adc	r26, r26
 ed0:	a4 17       	cp	r26, r20
 ed2:	10 f0       	brcs	.+4      	; 0xed8 <__utoa_common+0x14>
 ed4:	a4 1b       	sub	r26, r20
 ed6:	83 95       	inc	r24
 ed8:	50 51       	subi	r21, 0x10	; 16
 eda:	b9 f7       	brne	.-18     	; 0xeca <__utoa_common+0x6>
 edc:	a0 5d       	subi	r26, 0xD0	; 208
 ede:	aa 33       	cpi	r26, 0x3A	; 58
 ee0:	08 f0       	brcs	.+2      	; 0xee4 <__utoa_common+0x20>
 ee2:	a9 5d       	subi	r26, 0xD9	; 217
 ee4:	a1 93       	st	Z+, r26
 ee6:	00 97       	sbiw	r24, 0x00	; 0
 ee8:	79 f7       	brne	.-34     	; 0xec8 <__utoa_common+0x4>
 eea:	b1 11       	cpse	r27, r1
 eec:	b1 93       	st	Z+, r27
 eee:	11 92       	st	Z+, r1
 ef0:	cb 01       	movw	r24, r22
 ef2:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <strrev>

00000ef6 <strrev>:
 ef6:	dc 01       	movw	r26, r24
 ef8:	fc 01       	movw	r30, r24
 efa:	67 2f       	mov	r22, r23
 efc:	71 91       	ld	r23, Z+
 efe:	77 23       	and	r23, r23
 f00:	e1 f7       	brne	.-8      	; 0xefa <strrev+0x4>
 f02:	32 97       	sbiw	r30, 0x02	; 2
 f04:	04 c0       	rjmp	.+8      	; 0xf0e <strrev+0x18>
 f06:	7c 91       	ld	r23, X
 f08:	6d 93       	st	X+, r22
 f0a:	70 83       	st	Z, r23
 f0c:	62 91       	ld	r22, -Z
 f0e:	ae 17       	cp	r26, r30
 f10:	bf 07       	cpc	r27, r31
 f12:	c8 f3       	brcs	.-14     	; 0xf06 <strrev+0x10>
 f14:	08 95       	ret

00000f16 <_exit>:
 f16:	f8 94       	cli

00000f18 <__stop_program>:
 f18:	ff cf       	rjmp	.-2      	; 0xf18 <__stop_program>
